
AVRASM ver. 1.56  C:\MisProyectos\MP3Player\asms\GigaMP3.asm Wed Jul 30 18:45:27 2003


         ;-----------------------------------------------------------------------------
         ; FICHERO: GIGAMP3.asm
         ;
         ; DESCRIPCION: Modulo principal del reproductor.
         ;   Se definen los simbolos, constantes, etc... y se llaman a los diversos
         ;    modulos.
         ;
         ;-----------------------------------------------------------------------------
         
         ; Declaraciones estandar para este micro AT90S8515:
          .include "8515def.inc"
         ;***************************************************************************
         ;* A P P L I C A T I O N   N O T E   F O R   T H E   A V R   F A M I L Y
         ;* 
         ;* Number		:AVR000
         ;* File Name		:"8515def.inc"
         ;* Title		:Register/Bit Definitions for the AT90S8515
         ;* Date                 :99.01.28
         ;* Version              :1.30
         ;* Support telephone	:+47 72 88 43 88 (ATMEL Norway)
         ;* Support fax		:+47 72 88 43 99 (ATMEL Norway)
         ;* Support E-mail	:avr@atmel.com
         ;* Target MCU		:AT90S8515
         ;*
         ;* DESCRIPTION
         ;* When including this file in the assembly program file, all I/O register	
         ;* names and I/O register bit names appearing in the data book can be used.
         ;* In addition, the six registers forming the three data pointers X, Y and
         ;* Z have been assigned names XL - ZH. Highest RAM address for Internal 
         ;* SRAM is also defined 
         ;*
         ;* The Register names are represented by their hexadecimal address.
         ;* 
         ;* The Register Bit names are represented by their bit number (0-7).
         ;* 
         ;* Please observe the difference in using the bit names with instructions
         ;* such as "sbr"/"cbr" (set/clear bit in register) and "sbrs"/"sbrc" 
         ;* (skip if bit in register set/cleared). The following example illustrates
         ;* this:
         ;* 
         ;* in	r16,PORTB		;read PORTB latch
         ;* sbr	r16,(1<<PB6)+(1<<PB5)	;set PB6 and PB5 (use masks, not bit#)
         ;* out  PORTB,r16		;output to PORTB
         ;*
         ;* in	r16,TIFR		;read the Timer Interrupt Flag Register
         ;* sbrc	r16,TOV0		;test the overflow flag (use bit#)
         ;* rjmp	TOV0_is_set		;jump if set
         ;* ...				;otherwise do something else
         ;***************************************************************************
         
         ;***** Specify Device
          .device AT90S8515
         
         ;***** I/O Register Definitions
          .equ	SREG	=$3f
          .equ	SPH	=$3e
          .equ	SPL	=$3d
          .equ	GIMSK	=$3b
          .equ	GIFR	=$3a
          .equ	TIMSK	=$39
          .equ	TIFR	=$38
          .equ	MCUCR	=$35
         
          .equ	TCCR0	=$33
          .equ	TCNT0	=$32
          .equ	OCR0	=$31
         
          .equ	TCCR1A	=$2f
          .equ	TCCR1B	=$2e
          .equ	TCNT1H	=$2d
          .equ	TCNT1L	=$2c
          .equ	OCR1AH	=$2b
          .equ	OCR1AL	=$2a
          .equ	OCR1BH	=$29
          .equ	OCR1BL	=$28
          .equ	ICR1H	=$25
          .equ	ICR1L	=$24
         
          .equ	WDTCR	=$21
          .equ	EEARH	=$1f
          .equ	EEARL	=$1e
          .equ	EEDR	=$1d
          .equ	EECR	=$1c
         
          .equ	PORTA	=$1b
          .equ	DDRA	=$1a
          .equ	PINA	=$19
          .equ	PORTB	=$18
          .equ	DDRB	=$17
          .equ	PINB	=$16
          .equ	PORTC	=$15
          .equ	DDRC	=$14
          .equ	PINC	=$13
          .equ	PORTD	=$12
          .equ	DDRD	=$11
          .equ	PIND	=$10
         
          .equ	SPDR	=$0f
          .equ	SPSR	=$0e
          .equ	SPCR	=$0d
          .equ	UDR	=$0c
          .equ	USR	=$0b
          .equ	UCR	=$0a
          .equ	UBRR	=$09
          .equ	ACSR	=$08
         
         
         ;***** Bit Definitions
          .equ	INT1	=7
          .equ	INT0	=6
         
          .equ	INTF1	=7
          .equ	INTF0	=6
         
          .equ	TOIE1	=7
          .equ	OCIE1A	=6
          .equ	OCIE1B	=5
          .equ	TICIE1	=3
          .equ	TOIE0	=1
         
          .equ	TOV1	=7
          .equ	OCF1A	=6
          .equ	OCF1B	=5
          .equ	ICF1	=3
          .equ	TOV0	=1
         
          .equ	SRE	=7
          .equ	SRW	=6
          .equ	SE	=5
          .equ	SM	=4
          .equ	ISC11	=3
          .equ	ISC10	=2
          .equ	ISC01	=1
          .equ	ISC00	=0
         
          .equ	CS02	=2
          .equ	CS01	=1
          .equ	CS00	=0
         
          .equ	COM1A1	=7
          .equ	COM1A0	=6
          .equ	COM1B1	=5
          .equ	COM1B0	=4
          .equ	PWM11	=1
          .equ	PWM10	=0
         
          .equ	ICNC1	=7
          .equ	ICES1	=6
          .equ	CTC1	=3
          .equ	CS12	=2
          .equ	CS11	=1
          .equ	CS10	=0
         
          .equ	WDDE	=4
          .equ	WDE	=3
          .equ	WDP2	=2
          .equ	WDP1	=1
          .equ	WDP0	=0
         
          .equ	EEMWE	=2
          .equ	EEWE	=1
          .equ	EERE	=0
         
          .equ	PA7	=7
          .equ	PA6	=6
          .equ	PA5	=5
          .equ	PA4	=4
          .equ	PA3	=3
          .equ	PA2	=2
          .equ	PA1	=1
          .equ	PA0	=0
         
          .equ	DDA7	=7
          .equ	DDA6	=6
          .equ	DDA5	=5
          .equ	DDA4	=4
          .equ	DDA3	=3
          .equ	DDA2	=2
          .equ	DDA1	=1
          .equ	DDA0	=0
         
          .equ	PINA7	=7
          .equ	PINA6	=6
          .equ	PINA5	=5
          .equ	PINA4	=4
          .equ	PINA3	=3
          .equ	PINA2	=2
          .equ	PINA1	=1
          .equ	PINA0	=0
         
          .equ	PB7	=7
          .equ	PB6	=6
          .equ	PB5	=5
          .equ	PB4	=4
          .equ	PB3	=3
          .equ	PB2	=2
          .equ	PB1	=1
          .equ	PB0	=0
         
          .equ	DDB7	=7
          .equ	DDB6	=6
          .equ	DDB5	=5
          .equ	DDB4	=4
          .equ	DDB3	=3
          .equ	DDB2	=2
          .equ	DDB1	=1
          .equ	DDB0	=0
         
          .equ	PINB7	=7
          .equ	PINB6	=6
          .equ	PINB5	=5
          .equ	PINB4	=4
          .equ	PINB3	=3
          .equ	PINB2	=2
          .equ	PINB1	=1
          .equ	PINB0	=0
         
          .equ	PC7	=7
          .equ	PC6	=6
          .equ	PC5	=5
          .equ	PC4	=4
          .equ	PC3	=3
          .equ	PC2	=2
          .equ	PC1	=1
          .equ	PC0	=0
         
          .equ	DDC7	=7
          .equ	DDC6	=6
          .equ	DDC5	=5
          .equ	DDC4	=4
          .equ	DDC3	=3
          .equ	DDC2	=2
          .equ	DDC1	=1
          .equ	DDC0	=0
         
          .equ	PINC7	=7
          .equ	PINC6	=6
          .equ	PINC5	=5
          .equ	PINC4	=4
          .equ	PINC3	=3
          .equ	PINC2	=2
          .equ	PINC1	=1
          .equ	PINC0	=0
         
          .equ	PD7	=7
          .equ	PD6	=6
          .equ	PD5	=5
          .equ	PD4	=4
          .equ	PD3	=3
          .equ	PD2	=2
          .equ	PD1	=1
          .equ	PD0	=0
         
          .equ	DDD7	=7
          .equ	DDD6	=6
          .equ	DDD5	=5
          .equ	DDD4	=4
          .equ	DDD3	=3
          .equ	DDD2	=2
          .equ	DDD1	=1
          .equ	DDD0	=0
         
          .equ	PIND7	=7
          .equ	PIND6	=6
          .equ	PIND5	=5
          .equ	PIND4	=4
          .equ	PIND3	=3
          .equ	PIND2	=2
          .equ	PIND1	=1
          .equ	PIND0	=0
         
          .equ	SPIE	=7
          .equ	SPE	=6
          .equ	DORD	=5
          .equ	MSTR	=4
          .equ	CPOL	=3
          .equ	CPHA	=2
          .equ	SPR1	=1
          .equ	SPR0	=0
         
          .equ	SPIF	=7
          .equ	WCOL	=6
         
          .equ	RXC	=7
          .equ	TXC	=6
          .equ	UDRE	=5
          .equ	FE	=4
          .equ	OR	=3
         
          .equ	RXCIE	=7
          .equ	TXCIE	=6
          .equ	UDRIE	=5
          .equ	RXEN	=4
          .equ	TXEN	=3
          .equ	CHR9	=2
          .equ	RXB8	=1
          .equ	TXB8	=0
         
          .equ	ACD	=7
          .equ	ACO	=5
          .equ	ACI	=4
          .equ	ACIE	=3
          .equ	ACIC	=2
          .equ	ACIS1	=1
          .equ	ACIS0	=0
         
          .def	XL	=r26
          .def	XH	=r27
          .def	YL	=r28
          .def	YH	=r29
          .def	ZL	=r30
          .def	ZH	=r31
         
          .equ 	RAMEND  =$25F	;Last On-Chip SRAM Location
          .equ	XRAMEND =$FFFF
          .equ	E2END	=$1FF
          .equ	FLASHEND=$FFF
         
         
          .equ	INT0addr=$001	;External Interrupt0 Vector Address
          .equ	INT1addr=$002	;External Interrupt1 Vector Address
          .equ	ICP1addr=$003	;Input Capture1 Interrupt Vector Address
          .equ	OC1Aaddr=$004	;Output Compare1A Interrupt Vector Address
          .equ	OC1Baddr=$005	;Output Compare1B Interrupt Vector Address
          .equ	OVF1addr=$006	;Overflow1 Interrupt Vector Address
          .equ	OVF0addr=$007	;Overflow0 Interrupt Vector Address
          .equ	SPIaddr =$008	;SPI Interrupt Vector Address
          .equ	URXCaddr=$009	;UART Receive Complete Interrupt Vector Address
          .equ	UDREaddr=$00a	;UART Data Register Empty Interrupt Vector Address
          .equ	UTXCaddr=$00b	;UART Transmit Complete Interrupt Vector Address
          .equ	ACIaddr =$00c	;Analog Comparator Interrupt Vector Address
         
         ; --------------------------------------------------------
         ; 	Declaraciones  globales
         ; --------------------------------------------------------
         
          .equ  	PILA   			= 0x25F
          .equ	ATA_TEMP_BUF_TAM	= 128
          .equ	FAT_MAX_FILENAME	= 80		; Max. tam. de nombre de fich.
          .equ	ANCHO_LCD		= 20		; Tamaño del LCD
          .equ	VALOR_EXPL_LCD_RET      = 8		; Retardo hasta q texto empiza a deslizar
         
          .equ	VALOR_IR_TIMEOUT	= 1		; Retardo en teclas tras una tecla IR no de volumen
         
          .equ	PASO_VOLUMEN		= 4		; Cuando baja una pulsacion
         
         ; 32 secs = 16 kb = 1 segundo de buffer (a 128kbps)
          .equ	SECTORES_MP3_EN_RAM 	= 32		; Numero de sectores MP3 que se guardan 
         						;  en buffer de envio
         						
          .equ	ENVIOS_MP3_HASTA_CARGAR = 10* (512/32)	; Numero de envios de 32 bytes al decod. MP3
         						;  del bufer circular hasta que se vuelvan a 
         						;  cargar sectores nuevos.
         						; MAXIMO = 13 * ...
         
          .equ	FRECUENCIA_DISPLAY	= 0x7000	; Frecuencia de refresco de display para
         						;  el titulo de la cancion, etc.. (En us)
         
         
                     .DSEG	; Variables en RAM
                     .ORG		0x60
                               
         ; Variables generales
         ; ------------------------------------------------
000060      STR_BUF:		.BYTE	20	; Buffer para textos en general
         
                   
         ; Variables del modulo ATA:
         ; ------------------------------------------------
000074      LBA_DIR:		.BYTE 	4	; Direccion LBA 32 bits a un sector del disco
         					; Primer byte = Menos significativo
000078      SECTOR_CNT:		.BYTE	1
         
000079      ATA_WAITMASK_UNOS:	.BYTE	1
00007a      ATA_WAITMASK_CEROS:	.BYTE	1
         
         		; Buffer de lectura mientras RAM externa deshab.           
00007b      ATA_TEMP_BUF:		.BYTE	ATA_TEMP_BUF_TAM
         ; Tamaño de buffer     Tiempo para leer 2 Mbs (consecutivos)
         ; -----------------    --------------------------------------
         ;	32			5.86 seg
         ;	64			5.12 seg
         ;	128			4.75 seg ...(optimizado) 437 Kb/seg
         ;	256			4.56 seg  (demasiado grande, no merece la pena?)
         ;
         
         
0000fb      ATA_RDSECT_CUANTOSBUFS:	.BYTE 	1 	; Variable de la rutina de lectura q dice cuantos 
         					;   buffers hay q hacer para terminar la peticion
         
         
         ; Variables del modulo FAT:
         ; ------------------------------------------------
0000fc      BPB_SECSPERCLUS:	.BYTE	1	; Sectores por cluster
         
0000fd      BPB_CLUS_DIR_RAIZ:	.BYTE	4	; Numero de cluster de root
         
000101      FAT_PRIMER_SEC_DATOS:	.BYTE	4	; En LBA: primer byte= Menos sig.
000105      FAT_PRIMER_SEC_FAT:	.BYTE	4	; En LBA: primer byte= menos sig
         
000109      FAT_DIRECT_ACTUAL:	.BYTE	4	; Cluster del directorio actual
         
         			; El numero de sector LBA del sector cargado
         			;  en el buffer FAT_SEC_BUFFER, un sector de la FAT.
         			; Si se vuelve a consultar el mismo, no hace falta
         			;  volver al disco :-)
00010d      CACHE_FAT_SECTOR:	.BYTE	4	
         
         
         ; Parametros de la funcion FAT_EXPLORA_DIRECTORIO
         ; -------------------------------------------------------------
000111      FAT_PETICION:		.BYTE	1	
000112      FAT_PETICION_NUM_ENTR:	.BYTE	1	; Num. de entrada a leer por el explorador FAT32.
000113      FAT_DIRENT_ENCONTRADAS:	.BYTE	1	; Num. de entradas encontradas por el explorador
         
000114      FATEXPLORER_CLUSACT:	.BYTE	4	; Cluster actual en el directorio
         
         ; Directory Entry, recuperada por el FAT_EXPLORA_DIRECTORIO
         ;  Ya estan procesados campos como el cluster, nombre, etc...
         ; --------------------------------------------------------------
000118      FATDE_ATTR:		.BYTE	1	; Atributo: Fichero, directorio,...
000119      FATDE_CLUSTER:		.BYTE	4	; El primer cluster del fichero/directorio
00011d      FATDE_FILESIZE:		.BYTE	4	; Tamaño en bytes
         					; Nombre del fichero, acabado en 0x00
000121      FATDE_FILENAME:		.BYTE	FAT_MAX_FILENAME+1 	
000172      FATDE_FILENAME_CONTA:	.BYTE	1
         
         
         ;  MODO: Explorador de ficheros
         ; --------------------------------------------------------------
000173      EXPLORER_NUMENTS:	.BYTE	1
000174      EXPLORER_ENTACT:	.BYTE	1
000175      EXPLORER_LCD_OFFSET:	.BYTE	1	; Offset para texto deslizante en display
000176      EXPLORER_LCD_SENTIDO:	.BYTE	1	; 1 o -1 segun hacia donde vaya el texto
000177      EXPLORER_LCD_RETARDO:	.BYTE	1	; Contador hasta que el texto empiece a deslizarse
         
000178      COMANDO_USUARIO:	.BYTE	1	; Donde se guardan los comandos desde teclado o IR.
         
         
         ;  MODO: Reproduciendo MP3
         ; --------------------------------------------------------------
000179      REPROD_NUM_FICH_EN_DIR:	.BYTE	1	; Numero del fichero en el directorio o en la lista
         
00017a      REPROD_NUM_FICHS_TOTAL:	.BYTE	1	; Numero de ficheros en total en directorio o lista
         
         	; Cluster actual en el fichero
00017b      REPROD_FICH_CLUSTER:	.BYTE	4	
         
          	; Direccion en el buffer MP3_BUFFER de siguiente byte a 
          	;  enviar al chip decodificador cuando pida mas datos
          	;  es una especie de "cola circular"
00017f      REPROD_PTR_ENVIANDO:	.BYTE	2	; MSB primero
         
         	; Puntero en el buffer MP3_BUFFER del siguiente sector
         	;  a cargar de disco. No puede pasar de REPROD_PTR_ENVIANDO
         	;  asi que se configura un buffer circular :)
000181      REPROD_PTR_CARGAR:	.BYTE	2	; MSB primero
         
         	; Sector actual dentro del cluster actual (0..BPB_SECSPERCLUS)
000183      REPROD_FICH_SECT:	.BYTE	1
         
         	; Contador de bytes enviados QUE QUEDAN
000184      REPROD_BYTES_TX:	.BYTE	4	; LSB primero
         
000188      ENVIOS_MP3_PARA_CARGA:	.BYTE	1	; Contador de envios de 32 bytes para saber cuando 
         					;  volver a cargar sectores
         
000189      REPROD_EOF:		.BYTE	1	; Indicador de que se ha llegado al final del fichero
         
         
         ; Volumen de reproduccion: 0 = maximo. unidad = -0.5 db
00018a      VOLUMEN:		.BYTE	1	
         
         
         ; Flags varios:
00018b      REPROD_FLAGS:		.BYTE	1
         
          .equ	REPR_FLAG_SORROUND 	= 0
          .equ	REPR_FLAG_BASS 		= 1
          .equ	REPR_MODO_LISTA		= 2
          .equ	REPR_FLAG_PAUSE		= 3
         
         ; MODO MENU:
         ; ------------------------------------------------
00018c      MENU_OPCION:		.BYTE	1
         
         
         
         
         ; Codigos del mando a distancia
         ; ------------------------------------------------
00018d      IR_RX_BITS:		.BYTE	1	; Contador de bit actual
00018e      IR_BITS_1:		.BYTE	1	; Contador de intervalos a 1, para saber si es corto o largo
00018f      IR_CUENTA_0:		.BYTE	1	; Para saber cuando ha terminado la recepcion
000190      IR_TIMEOUT:		.BYTE	1	; Para retrasar entre una tecla y otra
         
000191      IR_CODE:		.BYTE	2	; Codigo recibido (temporal)
         
000193      IR_CODE_FINAL:		.BYTE	2	; Codigo recibido final
         
         
         ; Memoria RAM externa:
         ; ------------------------------------------------
          	.ORG	0x400
000400      SECTOR_BUFFER:		.byte	512	; Buffer general
         	
000600      FAT_SEC_BUFFER:		.byte	512	; Para cargar un sector de la FAT
         
000800      MP3_BUFFER:		.byte	512*SECTORES_MP3_EN_RAM
         	
         
         ; Buffer para una trama recibida por USB
004800      USB_COMANDO: 		.byte	1	
004801      USB_DATA:		.byte	550
         
         
         ; Cola FIFO usada por el creador de listas de reproduccion:
         ;  Las entradas son clusters de directorios a los que hay 
         ;  que examinar. Asi se evita usar recursividad y mas cosas:
          .equ	TAM_CREARLISTAS_COLA	= 70
         					; Numero de directorios max. en cola
004a27      CREAR_LST_COLA_DIRS:	.byte	4*TAM_CREARLISTAS_COLA
         					
004b3f      CREAR_LST_COLA_PTR_IN:	.byte   1	; Punteros de indice (1º=0) de entrada y salida en cola
004b40      CREAR_LST_COLA_PTR_OUT:	.byte   1	
         					; Es cola circular para mayor capacidad !
         	
         ; Listas de reproduccion:
004b41      LST_REPR_CUANTOS:	.byte	1	; Numero de entradas en lista
004b42      LST_REPR_ORDEN:		.byte	256	; Indices dentro de la lista siguiente:
004c42      LST_REPR_LISTA:		.byte	400	; Para que sobre... segun el numero de 
         					;  fichs. en cada directorio
         	; ------------------------------------------------
         	; El fomato de la lista es:
         	;
         	;  BYTES   CONTENIDO
         	; ====================
         	;    1       Numero de entradas en este directorio
         	;    4       Cluster del directorio 
         	;   Nx1	     Numero del fichero en ese directorio
         	;
         	; ------------------------------------------------
         
         
         ; Para guardar el directorio y la entrada desde donde se empezo
         ;  a reproducir, y poder volver al pulsar STOP mientras se reproduce:
004dd2      CONTEXT_EXPL_DIR:	.BYTE	4	; Cluster del direct. actual
004dd6      CONTEXT_EXPL_ENT:	.BYTE	1	; La entrada en el dir. act.
         
         ; Pila de elemento seleccionado en directorios anteriores, para
         ;  que al volver, se seleccione la carpeta en la que se entro:
004dd7      PILA_DIRECTORIOS_PTR:	.byte	2	; Puntero en la lista siguiente
         
         	; El numero de entrada:
004dd9      PILA_DIRECTORIOS_ENT:	.byte	1*100	; Profundidad de hasta 100 directorios !!
         
         
         	
         
          .def	temp		=r16
          .def	conta		=r17
          .def	temp2		=r18
          .def	aux		=r19
         
         ; Señales del modulo LCD
         ; -------------------------
          .equ	PULSADORES_PORT = PORTD
          .equ	PULSADORES_DDR  = DDRD
          .equ	PULSADORES_PIN  = PIND
          .equ	IR_PORT		= PORTD
          .equ	IR_DDR		= DDRD
          .equ	IR_PIN		= PIND
          .equ	IR_NUM_PIN	= 3
          .equ	PULS_NUM_PIN	= 4
         
         
         
         ; Bus IDE
         ; -------------------------
          .equ	IDE_PORT = PORTB
          .equ	IDE_DDR  = DDRB
          .equ	IDE_RD   = 1	; Los pins
          .equ	IDE_WR   = 0
         
         
         ; Señales para VS1001k
         ; -------------------------
          .equ	VS1001_PORT	= PORTB
          .equ	VS1001_DDR	= DDRB
          .equ	VS1001_PIN	= PINB
          .equ	VS1001_DREQ	= 2
          .equ	VS1001_BSYNC	= 3
          .equ	VS1001_MP3CS	= 4	; Pin SS 
         
         ; Señales para USB:
         ; -------------------
          .equ	USB_PORT	= PORTD
          .equ	USB_PIN		= PIND
          .equ	USB_DDR		= DDRD
          .equ	USB_PIN_RD	= 0
          .equ	USB_PIN_WR	= 1
          .equ	USB_PIN_RXF	= 2
                   
         
         ;----------------------------------------------------
         ; 	   Vectores de interrupcion
         ;----------------------------------------------------
                     .CSEG
                     .ORG     0x0000
000000 c009      	rjmp	RESET			; RESET
000001 9518      	reti				; INT0
000002 9518      	reti				; INT1
000003 9518      	reti
000004 9518      	reti
000005 9518      	reti
000006 9518      	reti
         
000007 cbc9      	rjmp	TMR0_INT		; TIMER 0 OVR.
         
000008 9518      	reti
000009 9518      	reti				; Byte recibido UART
         
         
         
         
         
         ; --------------------------------------------------------
         ;
         ;               	RUTINA DE RESET
         ;
         ; --------------------------------------------------------
          RESET:	
00000a e002      	ldi	temp,HIGH ( PILA )		; Preparar puntero de pila:
00000b bf0e      	out	SPH,temp		
00000c e50f      	ldi	r16,LOW (PILA ) 		
00000d bf0d      	out	SPL,temp		 	
         
         	;---------------------------------------------
         	; Inicializacion de puertos, modulos, etc...
         	;---------------------------------------------
         	
         	; Valores por defecto en pins (para uso "no alternativo" del pin)
00000e 2700      	clr	temp		; PORTC a 0
00000f bb04      	out	DDRC,temp
000010 bb05      	out	PORTC,temp
         	
         	
         	; Pins del disco duro: IDE_WR y IDE_RD a 1
000011 9ac0      	sbi	PORTB,0
000012 9ac1      	sbi	PORTB,1
000013 9ab8      	sbi	DDRB,0
000014 9ab9      	sbi	DDRB,1
         	
         	
         	; Pin de LCD_E salida a 0
000015 9a8d      	sbi	DDRD,  5
000016 9895      	cbi	PORTD, 5
         	
         	; Pulsadores: Salida a 1 (No detectar pulsaciones)
000017 9a94      	sbi	PULSADORES_PORT, PULS_NUM_PIN
000018 9a8c      	sbi	PULSADORES_DDR,  PULS_NUM_PIN
         	
         	; IR: Entrada con tiron
000019 9a93      	sbi	IR_PORT, IR_NUM_PIN
00001a 988b      	cbi	IR_DDR,  IR_NUM_PIN
         	
         
         
         	; Desactivar RAM externa:
00001b db15      	rcall	DESHAB_EXTRAM
         
         	; WR y RD de RAM externa: A 1 ambas para q no se active la RAM 
         	;  cuando se lea D1..D15 del disco duro (RAM externa desactivada)
00001c 9a8e      	sbi	DDRD, 6
00001d 9a96      	sbi	PORTD, 6
00001e 9a8f      	sbi	DDRD, 7
00001f 9a97      	sbi	PORTD, 7
         	
         
         	; Pins de USB:
000020 dc52      	rcall	USB_INICIAR
         		
         	; Interrupciones externas: Deshabilitar. Con tiron
         ;	cbi	DDRD, 2
         ;	sbi	PORTD, 2
         ;	cbi	DDRD, 3
         ;	sbi	PORTD, 3
         	
         ;	ldi	temp, 0x00
         ;	out	GIMSK, temp
         	
         	; TIMER0: Interrumpe cada x us
         	; ---------------------------------
         	
         	; CLK / 64:
000021 e003      	ldi	r16, 0x03
000022 bf03      	out	TCCR0,r16
         	
         	; Habilitar su int:
000023 e002      	ldi	r16, 0x02
000024 bf09      	out	TIMSK, r16
         	
         	
         
         
         	; Variables 
         	; --------------------------		
000025 e000      	ldi	r16, 0x00
000026 9300 0178 	sts	COMANDO_USUARIO, r16
         
000028 9300 018d 	sts	IR_RX_BITS,r16
00002a 9300 018e 	sts	IR_BITS_1,r16
00002c 9300 018f 	sts	IR_CUENTA_0, r16
         	
00002e 9300 0193 	sts	IR_CODE_FINAL+0, r16
000030 9300 0194 	sts	IR_CODE_FINAL+1, r16
         	
000032 9300 0190 	sts	IR_TIMEOUT, r16
         	
000034 9300 018b 	sts	REPROD_FLAGS, r16
         	
000036 e003      	ldi	r16, 3
000037 9300 0179 	sts	REPROD_NUM_FICH_EN_DIR, r16
         	
000039 e000      	ldi	r16, 0x00
00003a 9300 018a 	sts	VOLUMEN, r16
         
         	; --------------------------------------------
         	;     INICIO DEL PROGRAMA PRINCIPAL 
         	; --------------------------------------------
         	
         	; Esperar unas decimas:
00003c e19e      	ldi	r25, 30
00003d d7cb      	rcall	RETARDO_R25x25ms
         	
00003e d9cc      	rcall	LCD_INICIAR
         	
         
         	; Mostrar primera pantalla:
         	; --------------------------------------
00003f d9e5      	rcall	LCD_BORRAR
         	; 1º linea
000040 e1f5      	ldi	ZH, high( PRIMERA_PANTALLA1 * 2)
000041 e5e4      	ldi	ZL,  low( PRIMERA_PANTALLA1 * 2)
000042 da16      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
         	; 2º linea:
000043 e400      	ldi	r16, 0x40
000044 da20      	rcall	LCD_SET_CURSOR_POS_R16
000045 e1f5      	ldi	ZH, high( PRIMERA_PANTALLA2 * 2)
000046 e6ea      	ldi	ZL,  low( PRIMERA_PANTALLA2 * 2)
000047 da11      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
         	; Esperar un segundo aprox:
000048 e59f      	ldi	r25,  95
000049 d7bf      	rcall	RETARDO_R25x25ms
         	
         	; Hacer scroll para q se vaya el texto:
00004a d9dc      	rcall	LCD_SCROLL_ON
         
00004b e110      	ldi	conta, 16
          scroll_portada_loop:
00004c e200      	ldi	r16, ' '
00004d d9e6      	rcall	LCD_TX_DATO
         
00004e e092      	ldi	r25, 2
00004f d7b9      	rcall	RETARDO_R25x25ms
         	
000050 951a      	dec	conta
000051 f7d1      	brne	scroll_portada_loop
         	
         	
000052 d9d6      	rcall	LCD_SCROLL_OFF
000053 d9d1      	rcall	LCD_BORRAR
         
         
         	; Cargar caracteres para la barra del volumen:
         	; -------------------------------------------------
000054 e338      	ldi	aux, 8*LCD_USERCHARS_CUANTOS2
000055 e1f3      	ldi	ZH, high( LCD_USERCHARS2*2 )
000056 edee      	ldi	ZL,  low( LCD_USERCHARS2*2 )	
000057 d9c4      	rcall	LCD_CARGA_CARACTERES
         
         	
000058 d9cc      	rcall	LCD_BORRAR		
         	
         	; Check de RAM externa
         	; --------------------------------------
000059 e1f5      	ldi	ZH, high( STR_CHK_RAM * 2)
00005a e8e0      	ldi	ZL,  low( STR_CHK_RAM * 2)
00005b d9fd      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
         
         	; X = 0x0260 - 0x7FFF
         
         	; RAM externa:
00005c dacf      	rcall	HAB_EXTRAM
         
00005d e0b2      	ldi	XH, 0x02
00005e e6a0      	ldi	XL, 0x60
          check_ram_wr_loop:
00005f 2f0b      	mov	r16, XH
000060 270a      	eor	r16, XL
000061 930d      	st	X+, r16
         	
000062 38b0      	cpi	XH, 0x80
000063 f7d9      	brne	check_ram_wr_loop
         	
         
         	;	
000064 e0b2      	ldi	XH, 0x02
000065 e6a0      	ldi	XL, 0x60
          check_ram_rd_loop:
000066 2f1b      	mov	r17, XH
000067 271a      	eor	r17, XL
000068 910d      	ld	r16, X+
         	
000069 1701      	cp	r16,r17
00006a f419      	brne	chk_ram_error
         	
00006b 38b0      	cpi	XH, 0x80
00006c f7c9      	brne	check_ram_rd_loop
         	
         	; Ningun error!
00006d c005      	rjmp	chk_ram_ok	
         
         		
         	; RAM error:
          chk_ram_error:
         	; RAM externa:
00006e dac2      	rcall	DESHAB_EXTRAM
         
00006f e1f5      	ldi	ZH, high( STR_ER * 2)
000070 eae2      	ldi	ZL,  low( STR_ER * 2)
000071 d9e7      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
000072 cfff      colgado:rjmp	colgado
         	
         
         	; RAM Ok:
          chk_ram_ok:
         	; RAM externa:
000073 dabd      	rcall	DESHAB_EXTRAM
         
000074 e1f5      	ldi	ZH, high( STR_OK * 2)
000075 e9ee      	ldi	ZL,  low( STR_OK * 2)
000076 d9e2      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
         
         	; Variables en ram externa:
         	; -------------------------------
000077 dab4      	rcall	HAB_EXTRAM
         	
000078 e40d      	ldi	r16, high (PILA_DIRECTORIOS_ENT)	
000079 9300 4dd7 	sts	PILA_DIRECTORIOS_PTR+0, r16
         	
00007b ed09      	ldi	r16,  low (PILA_DIRECTORIOS_ENT)	
00007c 9300 4dd8 	sts	PILA_DIRECTORIOS_PTR+1, r16
         	
00007e dab2      	rcall	DESHAB_EXTRAM	
         
         	
         
         	; Checkear disco duro:
         	; ---------------------------------
00007f e400      	ldi	r16, 0x40
000080 d9e4      	rcall	LCD_SET_CURSOR_POS_R16
         	
000081 e1f5      	ldi	ZH, high( STR_TSTHD * 2)
000082 e8ee      	ldi	ZL,  low( STR_TSTHD * 2)
000083 d9d5      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
         
000084 d86f      	rcall	ATA_SeleccionarDisco
         
         
000085 e1f5      	ldi	ZH, high( STR_OK * 2)
000086 e9ee      	ldi	ZL,  low( STR_OK * 2)
000087 d9d1      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
000088 e19e      	ldi	r25, 30
000089 d77f      	rcall	RETARDO_R25x25ms
         	
00008a d99a      	rcall	LCD_BORRAR
         
         
         
         	; Comprobar FAT de disco OK y cargar valores importantes
         	; -----------------------------------------------------------
00008b d517      	rcall	FAT_INICIAR	; Escribe la primera linea LCD
         		
         	; Iniciar chip MP3:
         	; -----------------------------------------------------------
00008c dac4      	rcall	VS1001_INICIAR	
00008d db07      	rcall	VS1001_RESET
         	
         
         	; Y habilitar ints:
         	; --------------------------
00008e 9478      	sei
         
         	; Empezar en modo explorador, en directorio raiz:
         	; ---------------------------------------------------
00008f c1e5      	rjmp	MODO_EXPLORADOR
         	
         
         
         
         
         ; -----------------------------------------------------------
         ;   	MODO REPRODUCTOR
         ;
         ;  Llamado con RJMP. No sale hasta que no termina fichero
         ;
         ;
         ;  Entradas:
         ; -----------
         ; 
         ;	REPROD_NUM_FICH_EN_DIR: El numero de fich. a reproducir.
         ;
         ;
         ; -----------------------------------------------------------
          MODO_REPRODUCTOR:
         	; Quitar indicador de PAUSE:
         	; ------------------------------
000090 9100 018b 	lds	r16, REPROD_FLAGS
000092 7f07      	andi	r16, 0xF7
000093 9300 018b 	sts	REPROD_FLAGS, r16
         
         
         	; Reiniciar el decodificador entre cada cancion:
         	; -----------------------------------------------
         ;	ldi	r19, 2*2048/32
         ;	rcall	VS1001_TX_R19x32_CEROS
         	; Y esperar a q acabe:
         ;	ldi	r25, 9
         ;	rcall	RETARDO_R25x25ms	
         
000095 daff      	rcall	VS1001_RESET
         	
         	; Y Enviar config:
         	; -----------------------
000096 9100 018b 	lds	r16, REPROD_FLAGS
000098 2722      	clr	r18
000099 2733      	clr	r19
         	
00009a fd01      	sbrc	r16, REPR_FLAG_BASS
00009b 6830      	ori	r19, 0x80
00009c fd00      	sbrc	r16, REPR_FLAG_SORROUND
00009d 6031      	ori	r19, 0x01	
         	
         	; Enviar conf en r18/r19
00009e e010      	ldi	r17, VS1001ADDR_MODE
00009f dac2      	rcall	VS1001_ESC_REGISTRO
         	
         
0000a0 9100 018b 	lds	r16, REPROD_FLAGS
0000a2 fd02      	sbrc	r16, REPR_MODO_LISTA
0000a3 c020      	rjmp	modorepr_modo_lista
         	
         	; NO modo lista:
         	; --------------------
         	
         	; Coger datos del fichero a reproducir:
         	; ------------------------------------------
0000a4 e001      	ldi	r16, 1		; Peticion = coger datos
0000a5 9300 0111 	sts	FAT_PETICION,r16
         	; Numero de fichero a reproducir en el directorio actual:
0000a7 9100 0179 	lds	r16, REPROD_NUM_FICH_EN_DIR
0000a9 9300 0112 	sts	FAT_PETICION_NUM_ENTR,r16
0000ab d5fe      	rcall	FAT_EXPLORA_DIRECTORIO
         
         	; Si es un directorio, pasar a siguiente:
0000ac 9100 0118 	lds	r16, FATDE_ATTR
         	
0000ae fd04      	sbrc	r16, 4
0000af c15d      	rjmp	MODO_REPR_SIG_FICHERO	; Si es un directorio, ir a siguiente:
         	
         	
         	; Si no es MP3, pasar al siguiente:
0000b0 d734      	rcall	TEST_FILENAME_ES_MP3
0000b1 f008      	brcs	modo_repr_si_es_mp3	
0000b2 c15a      	rjmp	MODO_REPR_SIG_FICHERO	; No es ".MP3"
         	
          modo_repr_si_es_mp3:
         
         	
         	; En FATDE_CLUSTER esta el primer cluster del fichero:
0000b3 9100 0119 	lds	r16, FATDE_CLUSTER+0	
0000b5 9300 017b 	sts	REPROD_FICH_CLUSTER+0,r16
0000b7 9100 011a 	lds	r16, FATDE_CLUSTER+1	
0000b9 9300 017c 	sts	REPROD_FICH_CLUSTER+1,r16
0000bb 9100 011b 	lds	r16, FATDE_CLUSTER+2	
0000bd 9300 017d 	sts	REPROD_FICH_CLUSTER+2,r16
0000bf 9100 011c 	lds	r16, FATDE_CLUSTER+3
0000c1 9300 017e 	sts	REPROD_FICH_CLUSTER+3,r16
         
0000c3 c004      	rjmp	modorepr_ini_vals
         
         	; SI modo lista:
         	; -------------------------
          modorepr_modo_lista:
         	; Selecciona el fichero de la lista:
0000c4 9100 0179 	lds	r16, REPROD_NUM_FICH_EN_DIR
0000c6 dc7e      	rcall	SELEC_FICH_LISTA_ORDEN_R16 ;SELEC_FICH_LISTA_R16
         		
         	; Guardar cluster del fichero y empezar:
0000c7 cfeb      	rjmp	modo_repr_si_es_mp3	
         
         
          modorepr_ini_vals:
         	; Iniciar valores:
         	; -------------------
         	; EOF = 0
0000c8 2700      	clr	r16
0000c9 9300 0189 	sts	REPROD_EOF, r16
         	
         	; Puntero de datos a enviar al comienzo del buffer:
0000cb e008      	ldi	r16, high ( MP3_BUFFER )
0000cc 9300 017f 	sts	REPROD_PTR_ENVIANDO+0, r16
0000ce e000      	ldi	r16,  low ( MP3_BUFFER )
0000cf 9300 0180 	sts	REPROD_PTR_ENVIANDO+1, r16
         	
         	; Puntero de datos a cargar, al comienzo tambien:
0000d1 e008      	ldi	r16, high ( MP3_BUFFER )
0000d2 9300 0181 	sts	REPROD_PTR_CARGAR+0, r16
0000d4 e000      	ldi	r16,  low ( MP3_BUFFER )
0000d5 9300 0182 	sts	REPROD_PTR_CARGAR+1, r16
         
         	; Primer sector:
0000d7 2700      	clr	r16
0000d8 9300 0183 	sts	REPROD_FICH_SECT, r16
         
         	; Contador de bytes que quedan por enviar:
0000da 9100 011d 	lds	r16, FATDE_FILESIZE+0
0000dc 9300 0184 	sts	REPROD_BYTES_TX+0, r16
0000de 9100 011e 	lds	r16, FATDE_FILESIZE+1
0000e0 9300 0185 	sts	REPROD_BYTES_TX+1, r16
0000e2 9100 011f 	lds	r16, FATDE_FILESIZE+2
0000e4 9300 0186 	sts	REPROD_BYTES_TX+2, r16
0000e6 9100 0120 	lds	r16, FATDE_FILESIZE+3
0000e8 9300 0187 	sts	REPROD_BYTES_TX+3, r16
         	
         	; Contador de envios
0000ea 2700      	clr	r16
0000eb 9300 0188 	sts	ENVIOS_MP3_PARA_CARGA, r16
         
         	; Preparar valores para el display:
         	; ------------------------------------------------------------
0000ed d2e8      	rcall	PREPARAR_DATOS_LCD_FICHERO
         	
         	; En segunda linea poner donde estamos:
         	; ----------------
0000ee e0b0      	ldi	XH, high ( STR_BUF )
0000ef e6a0      	ldi	XL,  low ( STR_BUF )
         	
0000f0 9120 0179 	lds	r18, REPROD_NUM_FICH_EN_DIR
0000f2 d71f      	rcall	BYTE2ASCII_R18
         	
0000f3 e20f      	ldi	r16, '/'
0000f4 930d      	st	X+, r16
         	
0000f5 9120 017a 	lds	r18, REPROD_NUM_FICHS_TOTAL; EXPLORER_NUMENTS
0000f7 d71a      	rcall	BYTE2ASCII_R18
0000f8 d755      	rcall	CERO_2_X
         	
0000f9 e400      	ldi	r16, 0x40
0000fa d96a      	rcall	LCD_SET_CURSOR_POS_R16
         
0000fb e0b0      	ldi	XH, high ( STR_BUF )
0000fc e6a0      	ldi	XL,  low ( STR_BUF )
0000fd d986      	rcall	LCD_ESCRIBE_X
         
         
         
         	; Preparar TMR1 para que se desborde aprox. cada 0.3 segs:
         	; ------------------------------------------------------------
0000fe d302      	rcall	PREPARA_TMR1_OVR_300ms
         	
         
0000ff e000      	ldi	r16, 0x00
000100 9300 0178 	sts	COMANDO_USUARIO, r16
         
         	; Inicialmente llenar el buffer con sectores desde el disco:
         	; ------------------------------------------------------------
000102 d0b7      	rcall	MODO_REPR_CARGAR_SECTOR
         	
         	; Seguir cargando hasta dar la vuelta al buffer:
          modorepr_carga_inicial:
000103 9100 0181 	lds	r16, REPROD_PTR_CARGAR
000105 3008      	cpi	r16, high ( MP3_BUFFER )
000106 f011      	breq	modorepr_bucle	; Ya esta !
         	
000107 d0b2      	rcall	MODO_REPR_CARGAR_SECTOR
         	
000108 cffa      	rjmp	modorepr_carga_inicial	
         	
         	
          modorepr_bucle:
         	; ----------------------------------
         	; 	Ver que hay que hacer:
         	; ----------------------------------	
         
         	; Enviar MP3 ?	
         	; ----------------------------------
         	; Solo si no estamos en pausa:
000109 9100 018b 	lds	r16, REPROD_FLAGS
00010b fd03      	sbrc	r16, REPR_FLAG_PAUSE
00010c c002      	rjmp	modorepr_ver_si_cargar	; En pausa, saltar comprobacion:
         	
         	
00010d 99b2      	sbic	VS1001_PIN, VS1001_DREQ
00010e c06d      	rjmp	modorepr_envia_mp3	; DREQ=1 : Quiere datos
         
         	
          modorepr_ver_si_cargar:
         	; Cargar datos al buffer ?
         	; ----------------------------------
         	;   Solo NO se lee un sector si pilla justo el sector que 
         	;    se esta reproduciendo en este momento:
         	
         	
         	; Se calcula solo con las partes altas de las direcciones !
00010f 9100 0181 	lds	r16, REPROD_PTR_CARGAR
000111 9110 017f 	lds	r17, REPROD_PTR_ENVIANDO 	
         	
         	; ( brlo : si C=1 )
         	; Se tiene que cumplir que antes NO pille debajo 
         	;  y luego si. Si r20 acaba con un 0x02 no se puede
         	;  cargar el sector
000113 2744      	clr	r20
         	
         	; Con respecto al sector actual:
000114 1710      	cp	r17, r16
000115 b72f      	in	r18, SREG
000116 ff20      	sbrs	r18, 0	; Saltar si C=1: Si por debajo
000117 9543      	inc	r20 	; No reproduciendo por debajo
         	
         	
         	; Si leemos un sector, +=512 (0x0200)
000118 9503      	inc	r16
000119 9503      	inc	r16
         			
         	; Se supone que el valor maximo del ptr_cargar es el ultimo
         	;  sector, luego como mucho, quedara en ultimo_byte +1 y 
         	;  es mas facil no pasarlo al inicio, parar la comparacion:
00011a 1710      	cp	r17, r16
00011b b72f      	in	r18, SREG
00011c fd20      	sbrc	r18, 0	; Saltar si C=0: No por debajo
00011d 9543      	inc	r20 	; Si, reproduciendo por debajo
         
         	; Si se han cumplido las dos es porque el sector actual
         	;  esta siendo reproducido:
00011e 3042      	cpi	r20, 0x02
00011f f051      	breq	modorepr_nocargar_lleno
         	
         	
         	; Si, cargar, pero solo si el contador de envios esta OK:
         	; ----------------------------------------------------------
000120 9100 0188 	lds	r16, ENVIOS_MP3_PARA_CARGA
000122 3a00      	cpi	r16, ENVIOS_MP3_HASTA_CARGAR
000123 f048      	brlo	modorepr_nocargar
         	
         	
         	; Si el fichero acabo, no leer mas!!
000124 9100 0189 	lds	r16, REPROD_EOF
000126 2300      	tst	r16
000127 f411      	brne	modorepr_nocargar_lleno
         	
         	
         	; Si tengo al menos un sector para cargar:
         	; ------------------------------------------
         	; Cargar un sector, en el siguiente otro, etc...
         	;   cuando este lleno el buffer, se reteara el contador que 
         	;   hace que se cargen sentores, dando un buen margen de 
         	;   cache de lectura :-)
000128 d091      	rcall	MODO_REPR_CARGAR_SECTOR
000129 c003      	rjmp	modorepr_nocargar
         
          modorepr_nocargar_lleno:	
         	; Resetear contador: Solo si ya estamos con el buffer lleno del todo
00012a 2700      	clr	r16
00012b 9300 0188 	sts	ENVIOS_MP3_PARA_CARGA, r16
         	
         		
          modorepr_nocargar:
00012d da03      	rcall	DESHAB_EXTRAM
         	
         	; Actualizar pantalla?
         	; --------------------------
         	;  Si el TIMER1 se ha desbordado, es que han pasado 300 ms:
00012e b708      	in	r16, TIFR
         	
00012f ff06      	sbrs	r16, OCF1A	
000130 cfd8      	rjmp	modorepr_bucle
         		
         	
         	;  Llamar a las rutinas de actualizacion de display:
000131 d297      	rcall	ACTUALIZA_NOMBRE_FICH_LCD
000132 d26f      	rcall	ACTUALIZA_DESPLAZ_FICH_LCD
         	
         	; Actualizar Kbps y tiempo de reproduccion en la segunda linea
         	;   alineado a la derecha
000133 e0b0      	ldi	XH, high (STR_BUF)
000134 e6a0      	ldi	XL, low (STR_BUF)
         
000135 e200      	ldi	r16, ' '
000136 930d      	st	X+, r16
000137 930d      	st	X+, r16
000138 930d      	st	X+, r16
         
         	; Primero el Kbps o "PAUSE":
         	; ------------------------------
000139 9100 018b 	lds	r16, REPROD_FLAGS
00013b ff03      	sbrs	r16, REPR_FLAG_PAUSE
00013c c00b      	rjmp	modo_repr_no_pause
         
         	; Si en PAUSE:
00013d e500      	ldi	r16, 'P'
00013e 930d      	st	X+, r16
00013f e401      	ldi	r16, 'A'
000140 930d      	st	X+, r16
000141 e505      	ldi	r16, 'U'
000142 930d      	st	X+, r16
000143 e503      	ldi	r16, 'S'
000144 930d      	st	X+, r16
000145 e405      	ldi	r16, 'E'
000146 930d      	st	X+, r16	
000147 c007      	rjmp	modo_repr_tras_kbps
         
         
          modo_repr_no_pause:
000148 e015      	ldi	r17, VS1001ADDR_AUDATA
000149 da26      	rcall	VS1001_LEE_REGISTRO
         	
         	; Byte bajo (r19) es kbps:
00014a 2e23      	mov	r2, r19
00014b 2411      	clr	r1	
00014c d71b      	rcall	R1_R2_Decimal
         	
00014d e40b      	ldi	r16, 'K'
00014e 930d      	st	X+, r16
         
          modo_repr_tras_kbps:
00014f e200      	ldi	r16, ' '
000150 930d      	st	X+, r16
         	
         	
         	; Ahora el tiempo de reproduccion:
000151 e014      	ldi	r17, VS1001ADDR_DECODE_TIME
000152 da1d      	rcall	VS1001_LEE_REGISTRO
         	
         	
         	; Lo tengo en r18:r19 (MSB:LSB)
000153 d9ed      	rcall	CALCULA_MINUTOS
         	
         	; Devuelve en r1:r2 ( MSB:LSB ) el numero de minutos enteros
         	;  a partir del numero de segundos en r18:r19
         	; En r19 deja el numero de segundos que sobran
         	
000154 933f      	push	r19
         	
         	; "MIN:SEC"
000155 d712      	rcall	R1_R2_Decimal
         	
000156 e30a      	ldi	r16, ':'
000157 930d      	st	X+, r16
         
         	; Los segundos: Siempre las decenas
000158 912f      	pop	r18
000159 d6b8      	rcall	BYTE2ASCII_R18
         	
00015a d6f3      	rcall	CERO_2_X
         		
         	; Alinear a la derecha del display
00015b e0b0      	ldi	XH, high (STR_BUF)
00015c e6a0      	ldi	XL, low (STR_BUF)
00015d d938      	rcall	LCD_ESCRIBE_ABAJO_DERECHA_X	
         
         
         	; Ahora se miran las teclas, para que solo sean 
         	;  una pulsacion cada XXX ms		
         	; Algun comando del user? Puls y IR
         	; -----------------------------------
00015e d3fa      	rcall	LEE_PULS_Y_IR
         
00015f 9100 0178 	lds	r16, COMANDO_USUARIO	; Del tecl o IR
000161 2300      	tst	r16
000162 f0b9      	breq	modorepr_no_cmds
         	
         	; Borrar para q no se repita!
000163 2711      	clr	r17
000164 9310 0178 	sts	COMANDO_USUARIO, r17
         	
         	; Si hay un comando: Enrutar segun sea:
000166 3005      	cpi	r16, PULS_ALANTE
000167 f409      	brne	modorepr_sk1
000168 c0a4      	rjmp	MODO_REPR_SIG_FICHERO
          modorepr_sk1:	
000169 3006      	cpi	r16, PULS_ATRAS
00016a f409      	brne	modorepr_sk2
00016b c0ad      	rjmp	MODO_REPR_ANT_FICHERO
          modorepr_sk2:	
00016c 3008      	cpi	r16, PULS_VOL_MAS
00016d f411      	brne	modorepr_sk3
00016e d0b6      	rcall	MODO_REPR_VOL_MAS
00016f c00a      	rjmp	modorepr_no_cmds
         	
          modorepr_sk3:	
000170 3007      	cpi	r16, PULS_VOL_MENOS
000171 f411      	brne	modorepr_sk4
000172 d0e8      	rcall	MODO_REPR_VOL_MENOS
000173 c006      	rjmp	modorepr_no_cmds
         	
          modorepr_sk4:	
000174 3004      	cpi	r16, PULS_STOP
000175 f409      	brne	modorepr_sk5
000176 c0f6      	rjmp	MODO_REPR_STOP
          modorepr_sk5:	
000177 3003      	cpi	r16, PULS_PLAY
000178 f409      	brne	modorepr_sk6
000179 c0ec      	rjmp	MODO_REPR_PLAY
          modorepr_sk6:	
         
         
         
         	
          modorepr_no_cmds:	
         
         	; Quitar flags y volver a cargar:
00017a d286      	rcall	PREPARA_TMR1_OVR_300ms	
         	
         	; No salir del bucle:
00017b cf8d      	rjmp	modorepr_bucle
         
         	
         
         	; El chip quiere datos, darle hasta que no pida mas:
         	; ------------------------------------------------------
          modorepr_envia_mp3:
00017c d9af      	rcall	HAB_EXTRAM
         
         	; En (X) el puntero a posicion actual:
00017d 91b0 017f 	lds	XH, REPROD_PTR_ENVIANDO 
00017f 91a0 0180 	lds	XL, REPROD_PTR_ENVIANDO + 1
         	
         	
          modorepr_envia_mp3_lp:
000181 da08      	rcall	VS1001_TX_MPEG_DATA_32X
         
         	; Contador de envios
000182 9100 0188 	lds	r16, ENVIOS_MP3_PARA_CARGA
000184 9503      	inc	r16
000185 9300 0188 	sts	ENVIOS_MP3_PARA_CARGA, r16
         	
         	; Contador de bytes que quedan: Restar 32:
000187 9020 0184 	lds	r2, REPROD_BYTES_TX+0
000189 9030 0185 	lds	r3, REPROD_BYTES_TX+1
00018b 9040 0186 	lds	r4, REPROD_BYTES_TX+2
00018d 9050 0187 	lds	r5, REPROD_BYTES_TX+3
         
00018f 2400      	clr	r0
000190 e200      	ldi	r16, 32
000191 1a20      	sub	r2, r16
000192 0830      	sbc	r3, r0
000193 0840      	sbc	r4, r0
000194 0850      	sbc	r5, r0
         	
         		
000195 9220 0184 	sts	REPROD_BYTES_TX+0, r2
000197 9230 0185 	sts	REPROD_BYTES_TX+1, r3
000199 9240 0186 	sts	REPROD_BYTES_TX+2, r4
00019b 9250 0187 	sts	REPROD_BYTES_TX+3, r5
         	
         	; Es cero (r2=r3=r4=r5=0) o negativo(C=1) ??
00019d f040      	brcs	modorepr_envmp3_EOF
         	
00019e 2022      	tst	r2
00019f f439      	brne	modorepr_envmp3_sigue	
0001a0 2033      	tst	r3
0001a1 f429      	brne	modorepr_envmp3_sigue	
0001a2 2044      	tst	r4
0001a3 f419      	brne	modorepr_envmp3_sigue	
0001a4 2055      	tst	r5
0001a5 f409      	brne	modorepr_envmp3_sigue	
         	
          modorepr_envmp3_EOF:
         	; Fin de fichero, pasar a siguiente:
0001a6 c066      	rjmp	MODO_REPR_SIG_FICHERO
         	
         	
          modorepr_envmp3_sigue:	
         	; Fin del buffer?
0001a7 34b8      	cpi	XH, high ( MP3_BUFFER + 512*SECTORES_MP3_EN_RAM  )
0001a8 f411      	brne	modorepr_envmp3_no_ovr
         	
         	; Dar la vuelta al puntero:
0001a9 e0b8      	ldi	XH, high ( MP3_BUFFER )
0001aa e0a0      	ldi	XL,  low ( MP3_BUFFER )
         	
          modorepr_envmp3_no_ovr:	
         
         	; Hay mas datos para enviar ??
         	;  Si XH = high ( REPROD_PTR_CARGAR )  y XL = 0x00
         	;  no hay mas datos !!
0001ab 23aa      	tst	XL
0001ac f429      	brne	modorepr_envia_mp3_si
         	
0001ad 9100 0181 	lds	r16, REPROD_PTR_CARGAR + 0
0001af 170b      	cp	r16, XH
0001b0 f409      	brne	modorepr_envia_mp3_si
         	
         	; Pues no hay mas datos, cargar antes:
0001b1 c002      	rjmp	modorepr_envmp3_fin_envios
         	
          modorepr_envia_mp3_si:
         	
         	; Aun quiere mas ?	
0001b2 99b2      	sbic	VS1001_PIN, VS1001_DREQ
0001b3 cfcd      	rjmp	modorepr_envia_mp3_lp; DREQ = 1 : Mas
         	; DREQ = 0 : No mas datos por ahora
         
          modorepr_envmp3_fin_envios:
         		
0001b4 d97c      	rcall	DESHAB_EXTRAM
         
         	; Guardar puntero para seguir luego
0001b5 93b0 017f 	sts	REPROD_PTR_ENVIANDO, XH
0001b7 93a0 0180 	sts	REPROD_PTR_ENVIANDO + 1, XL
         
         	; Despues de enviar, cargar nuevos datos
0001b9 cf55      	rjmp	modorepr_ver_si_cargar
         	
         	
         ; -----------------------------------------------------------
         ;   MODO_REPR_CARGAR_SECTOR
         ;
         ;  Rutina que carga un nuevo sector en el buffer circular, 
         ;   actualizando punteros, numero de sector, clusters, ...
         ; -----------------------------------------------------------
          MODO_REPR_CARGAR_SECTOR:
         	; Pasar de cluster actual a sector:
0001ba 9020 017b 	lds	r2, REPROD_FICH_CLUSTER + 0
0001bc 9030 017c 	lds	r3, REPROD_FICH_CLUSTER + 1
0001be 9040 017d 	lds	r4, REPROD_FICH_CLUSTER + 2
0001c0 9050 017e 	lds	r5, REPROD_FICH_CLUSTER + 3
         	
0001c2 d44b      	rcall	FAT_CLUSTER2SECTOR
         	
         	; Sumar el sector actual dentro de este cluster:
0001c3 90d0 0183 	lds	r13, REPROD_FICH_SECT
         	
0001c5 9020 0074 	lds	r2, LBA_DIR+0
0001c7 9030 0075 	lds	r3, LBA_DIR+1
0001c9 9040 0076 	lds	r4, LBA_DIR+2
0001cb 9050 0077 	lds	r5, LBA_DIR+3
         
0001cd 2400      	clr	r0
0001ce 0c2d      	add	r2, r13
0001cf 1c30      	adc	r3, r0
0001d0 1c40      	adc	r4, r0
0001d1 1c50      	adc	r5, r0
         
         	; Leer ese sector en donde indica el puntero REPROD_PTR_CARGAR
0001d2 9220 0074 	sts	LBA_DIR+0, r2
0001d4 9230 0075 	sts	LBA_DIR+1, r3
0001d6 9240 0076 	sts	LBA_DIR+2, r4
0001d8 9250 0077 	sts	LBA_DIR+3, r5
         	
0001da e001      	ldi	r16, 0x01	; 1 sector
0001db 9300 0078 	sts	SECTOR_CNT, r16
         	
         	; Destino en (Y):
0001dd 91d0 0181 	lds	YH, REPROD_PTR_CARGAR + 0 
0001df 91c0 0182 	lds	YL, REPROD_PTR_CARGAR + 1 
         	
0001e1 d730      	rcall	ATA_ReadSectors
         	
         	; Sector leido !
         	
         	; Ahora (Y) apunta detras del ultimo byte
         	; Si se pasa del buffer, resetearlo:
0001e2 34d8      	cpi	YH, high ( MP3_BUFFER + 512 * SECTORES_MP3_EN_RAM )
0001e3 f411      	brne	modorpr_crgsec_no_ovr
         	
         	; Si, resetear puntero:
0001e4 e0d8      	ldi	YH, high ( MP3_BUFFER )
0001e5 e0c0      	ldi	YL,  low ( MP3_BUFFER )
         
          modorpr_crgsec_no_ovr:
         	; Y guardarlo!!
0001e6 93d0 0181 	sts	REPROD_PTR_CARGAR , YH
0001e8 93c0 0182 	sts	REPROD_PTR_CARGAR+1,YL
         	
         
         	; Incrementar contador de sector dentro del cluster actual:
0001ea 90d0 0183 	lds	r13, REPROD_FICH_SECT
0001ec 9100 00fc 	lds	r16, BPB_SECSPERCLUS
         	
0001ee 94d3      	inc	r13
0001ef 16d0      	cp	r13, r16
0001f0 f4c9      	brne	modorpr_crgsec_no_secovr
         	
         	; Se ha pasado:
0001f1 24dd      	clr	r13
0001f2 92d0 0183 	sts	REPROD_FICH_SECT, r13
         	
         	; Siguiente cluster:
0001f4 9020 017b 	lds	r2, REPROD_FICH_CLUSTER + 0
0001f6 9030 017c 	lds	r3, REPROD_FICH_CLUSTER + 1
0001f8 9040 017d 	lds	r4, REPROD_FICH_CLUSTER + 2
0001fa 9050 017e 	lds	r5, REPROD_FICH_CLUSTER + 3
         
0001fc d436      	rcall	FAT_SIGUIENTE_CLUSTER
         	; Fin de fichero? Si C=1
0001fd f418      	brcc	modorpr_crgsec_no_eof
         
         	; EOF = 1
0001fe e001      	ldi	r16, 0x01
0001ff 9300 0189 	sts	REPROD_EOF, r16
         
          modorpr_crgsec_no_eof:
000201 9220 017b 	sts	REPROD_FICH_CLUSTER + 0 , r2
000203 9230 017c 	sts	REPROD_FICH_CLUSTER + 1 , r3
000205 9240 017d 	sts	REPROD_FICH_CLUSTER + 2 , r4
000207 9250 017e 	sts	REPROD_FICH_CLUSTER + 3 , r5	
         	
         	
         	; Ya no hay que guardar el valor de r13
000209 1000      	cpse	r0,r0	
          modorpr_crgsec_no_secovr:
         	; Guardar nuevo numero de sector:
00020a 92d0 0183 	sts	REPROD_FICH_SECT, r13
         
         	
         
00020c 9508      	ret
         
         ;==================================================================
         ; 		 CMD: Siguiente fichero
         ;==================================================================
          MODO_REPR_SIG_FICHERO:
         	; Enviar ceros para asegurar fin de cancion
00020d d987      	rcall	VS1001_RESET
         
         	; Siguiente archivo
00020e 9100 0179 	lds	r16, REPROD_NUM_FICH_EN_DIR
000210 9110 017a 	lds	r17, REPROD_NUM_FICHS_TOTAL
000212 9503      	inc	r16
         	
000213 1710      	cp	r17, r16
000214 f408      	brsh	modo_repr_sig
         	
         	; Seleccionar primer directorio/fichero:
000215 e001      	ldi	r16, 0x01
          modo_repr_sig:	
000216 9300 0179 	sts	REPROD_NUM_FICH_EN_DIR, r16
         	
         
         	; Reproducirlo:
000218 ce77      	rjmp	MODO_REPRODUCTOR
         
         
         ;==================================================================
         ; 		 CMD: Anterior
         ;==================================================================
          MODO_REPR_ANT_FICHERO:
         	; Enviar ceros para asegurar fin de cancion
000219 d97b      	rcall	VS1001_RESET
         
         	; Anterior archivo
00021a 9100 0179 	lds	r16, REPROD_NUM_FICH_EN_DIR
         	
         	; Si ya es el primero, ir al ultimo:
00021c 3001      	cpi	r16, 0x01
00021d f011      	breq	modo_repr_ant
         
00021e 950a      	dec	r16
00021f c002      	rjmp	modo_repr_ant_grd
         		
          modo_repr_ant:	
         	; Ir al ultimo:
000220 9100 017a 	lds	r16, REPROD_NUM_FICHS_TOTAL
         	
          modo_repr_ant_grd:
000222 9300 0179 	sts	REPROD_NUM_FICH_EN_DIR, r16
         
         	; Reproducirlo:
000224 ce6b      	rjmp	MODO_REPRODUCTOR
         
         
         ;==================================================================
         ; 		 CMD: Subir volumen:
         ;  Es RUTINA !!
         ;==================================================================
          MODO_REPR_VOL_MAS:
000225 9100 018a 	lds	r16, VOLUMEN
         	
000227 2300      	tst	r16
000228 f009      	breq	vol_mas_max
         	
         	; Subir volumen:
000229 5004      	subi	r16, PASO_VOLUMEN
          vol_mas_max:	
         	
         	; Y guardarlo en ram y cambiarlo en el chip:
00022a 9300 018a 	sts	VOLUMEN, r16
00022c 2f10      	mov	r17, r16
00022d d98e      	rcall	VS1001_CAMBIAR_VOLUMEN
         
          volumen_en_display:
         	; Y mostrarlo en display:
         	; -------------------------------
00022e d902      	rcall	DESHAB_EXTRAM
         	
00022f e0b0      	ldi	XH, high ( STR_BUF )	
000230 e6a0      	ldi	XL,  low ( STR_BUF )	
         
         	
         	; Poner en dBs
         
         	; Solo poner el - si es !=0
000231 2411      	clr	r1
000232 9020 018a 	lds	r2, VOLUMEN
000234 9426      	lsr	r2
         	
000235 e200      	ldi	r16, ' '
000236 2022      	tst	r2
000237 f009      	breq	vol_en_displ_cero	
000238 e20d      	ldi	r16, '-'
          vol_en_displ_cero:
000239 930d      	st	X+, r16
         
00023a d62d      	rcall	R1_R2_Decimal
         	
00023b e604      	ldi	r16, 'd'
00023c 930d      	st	X+, r16
00023d e402      	ldi	r16, 'B'
00023e 930d      	st	X+, r16
         
          vol_en_displ_rellena:
00023f 36a7      	cpi	XL, low ( STR_BUF + 7 )
000240 f019      	breq	vol_en_displ_rellena_fin
         
000241 e200      	ldi	r16, ' '
000242 930d      	st	X+, r16
000243 cffb      	rjmp	vol_en_displ_rellena
         	
          vol_en_displ_rellena_fin:	
         
         	; Dibujar la barra del volumen:
         	;
         	;  Caracteres    0x20 y 1,2,3,4,5: barras verticales
         	; corresponden a:  0    1 2 3 4 5 barras de 5
         	; ---------------------------------------------
000244 9110 018a 	lds	r17, VOLUMEN
000246 9510      	com	r17
          vol_en_lcd_lp:
000247 3114      	cpi	r17, 4*5
000248 f420      	brsh	vol_en_lcd_mas
         
         	; Si es < 4*5, poner el caracter que sea y fin de la barra:
         	; Dividir r17 entre 4
000249 9516      	lsr	r17
00024a 9516      	lsr	r17		
         	
00024b 931d      	st	X+, r17
00024c c004      	rjmp	vol_en_lcd_fin
         		
         	; Es > 25 todavia: Poner cuadro entero y restar:
          vol_en_lcd_mas:
00024d e005      	ldi	r16, 0x05
00024e 930d      	st	X+, r16
         
00024f 5114      	subi	r17, 4*5
         	
000250 cff6      	rjmp	vol_en_lcd_lp
         	
          vol_en_lcd_fin:
         
000251 d5fc      	rcall	CERO_2_X
         
         	; Al LCD:
000252 e000      	ldi	r16, 0
000253 d811      	rcall	LCD_SET_CURSOR_POS_R16
000254 d84d      	rcall	LCD_BORRAR_LINEA
         	
         		
000255 e000      	ldi	r16, 0
000256 d80e      	rcall	LCD_SET_CURSOR_POS_R16
         	
000257 e0b0      	ldi	XH, high ( STR_BUF )	
000258 e6a0      	ldi	XL,  low ( STR_BUF )	
000259 d82a      	rcall	LCD_ESCRIBE_X
         	
         	
         
         		
         	
00025a 9508      	ret
         	
         ;==================================================================
         ; 		 CMD: Bajar volumen:
         ;  Es RUTINA !!
         ;==================================================================
          MODO_REPR_VOL_MENOS:
00025b 9100 018a 	lds	r16, VOLUMEN
         	
00025d 3f0c      	cpi	r16, (0x100 - PASO_VOLUMEN)
00025e f011      	breq	vol_menos_max
         	
         	; Subir volumen:
00025f e014      	ldi	r17, PASO_VOLUMEN
000260 0f01      	add	r16, r17
          vol_menos_max:	
         	
         	; Y guardarlo en ram y cambiarlo en el chip:
000261 9300 018a 	sts	VOLUMEN, r16
000263 2f10      	mov	r17, r16
000264 d957      	rcall	VS1001_CAMBIAR_VOLUMEN
         
         	; Y mostrarlo en display:
000265 cfc8      	rjmp	volumen_en_display		
         
         	
         ;==================================================================
         ; 		 CMD: PLAY/PAUSE
         ;==================================================================
          MODO_REPR_PLAY:
000266 9100 018b 	lds	r16, REPROD_FLAGS
000268 e018      	ldi	r17, 1 << REPR_FLAG_PAUSE
000269 2701      	eor 	r16, r17
00026a 9300 018b 	sts	REPROD_FLAGS, r16
         	
00026c cf0d      	rjmp	modorepr_no_cmds
         	
         	
         	
         ;==================================================================
         ; 		 CMD: Stop
         ;==================================================================
          MODO_REPR_STOP:
         	; Salir al modo explorador:
00026d d927      	rcall	VS1001_RESET
         	
         	; Quitar modo lista
00026e 9100 018b 	lds	r16, REPROD_FLAGS
000270 7f0b      	andi	r16, 0xFB	
000271 9300 018b 	sts	REPROD_FLAGS, r16
         	
         	; Recuperar el directorio y entrada por la que ibamos:
000273 d311      	rcall	RECUPERA_CONTEXT_EXPLORADOR
         
000274 c006      	rjmp	MODO_EXPLORADOR_CAMBIA_DIRECT2
         			
         
         	
         ; -----------------------------------------------------------
         ;
         ;   	MODO EXPLORADOR
         ;
         ; -----------------------------------------------------------
          MODO_EXPLORADOR:
         
000275 e000      	ldi	r16, 0x00
000276 9300 0178 	sts	COMANDO_USUARIO, r16
         
         ; ------------------------------------	
         ;   Refrescar cuando cambia el 
         ;  directorio actual
         ; ------------------------------------
          MODO_EXPLORADOR_CAMBIA_DIRECT:
         	; Seleccionar primer directorio/fichero:
000278 e001      	ldi	r16, 0x01
000279 9300 0174 	sts	EXPLORER_ENTACT, r16
         	
          MODO_EXPLORADOR_CAMBIA_DIRECT2:
         	; Contar entradas en directorio actual:
00027b e000      	ldi	r16, 0		; Peticion = solo contar entradas
00027c 9300 0111 	sts	FAT_PETICION,r16
00027e d42b      	rcall	FAT_EXPLORA_DIRECTORIO
         		
         	; Guardar cuantas son:
00027f 9100 0113 	lds	r16, FAT_DIRENT_ENCONTRADAS
000281 9300 0173 	sts	EXPLORER_NUMENTS, r16
         	
         	
         	; Para asegurar q el buffer esta vacio de entrada:
000283 e000      	ldi	r16, 0x00
000284 9300 0121 	sts	FATDE_FILENAME, r16	
         
         ; ------------------------------------	
         ;   Refrescar cuando cambia el 
         ;  fichero seleccionado	
         ; ------------------------------------
          MODO_EXPLORADOR_CAMBIA_FICH:
         
         	; Cargar datos del fich/dir seleccionado:
         	; -----------------------------------------
000286 e001      	ldi	r16, 1		; Peticion = coger datos
000287 9300 0111 	sts	FAT_PETICION,r16
000289 9100 0174 	lds	r16, EXPLORER_ENTACT
00028b 9300 0112 	sts	FAT_PETICION_NUM_ENTR,r16
         	
00028d d41c      	rcall	FAT_EXPLORA_DIRECTORIO
         
         	; ***
00028e d147      	rcall	PREPARAR_DATOS_LCD_FICHERO
         
         	; En segunda linea poner donde estamos:
         	; ----------------
00028f e0b0      	ldi	XH, high ( STR_BUF )
000290 e6a0      	ldi	XL,  low ( STR_BUF )
         	
000291 9120 0174 	lds	r18, EXPLORER_ENTACT
000293 d57e      	rcall	BYTE2ASCII_R18
         	
000294 e20f      	ldi	r16, '/'
000295 930d      	st	X+, r16
         	
000296 9120 0173 	lds	r18, EXPLORER_NUMENTS
000298 d579      	rcall	BYTE2ASCII_R18
000299 d5b4      	rcall	CERO_2_X
         	
00029a e400      	ldi	r16, 0x40
00029b d7c9      	rcall	LCD_SET_CURSOR_POS_R16
         
00029c e0b0      	ldi	XH, high ( STR_BUF )
00029d e6a0      	ldi	XL,  low ( STR_BUF )
00029e d7e5      	rcall	LCD_ESCRIBE_X
         
         	
         	; Poner a la derecha el tamaño en Kbs:
00029f e0b0      	ldi	XH, high ( STR_BUF )
0002a0 e6a0      	ldi	XL,  low ( STR_BUF )
         
         
         	; En Kbs es >> 10:
0002a1 9000 0120 	lds	r0, FATDE_FILESIZE+3
0002a3 9010 011f 	lds	r1, FATDE_FILESIZE+2
0002a5 9020 011e 	lds	r2, FATDE_FILESIZE+1
         	
         	; Ahora >> 2
0002a7 9406      	lsr	r0
0002a8 9417      	ror	r1
0002a9 9427      	ror	r2
         
0002aa 9406      	lsr	r0
0002ab 9417      	ror	r1
0002ac 9427      	ror	r2
         
0002ad d5bb      	rcall	R0_R1_R2_Decimal
         
         	
0002ae e200      	ldi	r16, ' '
0002af 930d      	st	X+, r16
0002b0 e40b      	ldi	r16, 'K'
0002b1 930d      	st	X+, r16
0002b2 e602      	ldi	r16, 'b'
0002b3 930d      	st	X+, r16
0002b4 d599      	rcall	CERO_2_X
         
         
         	; Alinear a la derecha del display
0002b5 d7e0      	rcall	LCD_ESCRIBE_ABAJO_DERECHA_X
         
         ;	ldi	r16, 0x00
         ;	sts	COMANDO_USUARIO, r16
         
0002b6 d112      	rcall	ACTUALIZA_NOMBRE_FICH_LCD
         	
         ; ------------------------------------	
         ;    Solo refresca primera linea
         ; ------------------------------------
          MODO_EXPLORADOR_LOOP:
         	; Retardo de cada ciclo: 300 ms aprox
         	; ------------------------------------------
0002b7 e09a      	ldi	r25, 10
0002b8 d550      	rcall	RETARDO_R25x25ms
         
0002b9 d10f      	rcall	ACTUALIZA_NOMBRE_FICH_LCD
         
         				
         	; Algo del chip USB?
         	; --------------------
0002ba 9b82      	sbis	USB_PIN, USB_PIN_RXF
0002bb c9be      	rjmp	MODO_USB 		; RXF = 0
         
         		
         	; Algun comando del teclado / mando a distancia??
         	; -------------------------------------------------
0002bc d29c      	rcall	LEE_PULS_Y_IR
         	
          modoexpl_seguncomando:
0002bd 9100 0178 	lds	r16, COMANDO_USUARIO	; Del tecl o IR
0002bf 2300      	tst	r16
0002c0 f0f9      	breq	modoexplo_nocmd
         	
0002c1 e010      	ldi	r17, 0x00
0002c2 9310 0178 	sts	COMANDO_USUARIO, r17
         	
         	;  Segun comando:
0002c4 3005      	cpi	r16, PULS_ALANTE
0002c5 f409      	brne	modoexplo_sk1
0002c6 c051      	rjmp	MODO_EXPLO_SIG_FICHERO
          modoexplo_sk1:	
0002c7 3006      	cpi	r16, PULS_ATRAS
0002c8 f409      	brne	modoexplo_sk2
0002c9 c059      	rjmp	MODO_EXPLO_ANT_FICHERO
          modoexplo_sk2:	
0002ca 3008      	cpi	r16, PULS_VOL_MAS
0002cb f411      	brne	modoexplo_sk3
0002cc df58      	rcall	MODO_REPR_VOL_MAS
0002cd c012      	rjmp	modoexplo_nocmd
         	
          modoexplo_sk3:	
0002ce 3007      	cpi	r16, PULS_VOL_MENOS
0002cf f411      	brne	modoexplo_sk4
0002d0 df8a      	rcall	MODO_REPR_VOL_MENOS
0002d1 c00e      	rjmp	modoexplo_nocmd
         	
          modoexplo_sk4:	
0002d2 3003      	cpi	r16, PULS_PLAY
0002d3 f409      	brne	modoexplo_sk5
0002d4 c059      	rjmp	MODO_EXPLO_PLAY
         
          modoexplo_sk5:	
0002d5 3004      	cpi	r16, PULS_STOP
0002d6 f431      	brne	modoexplo_sk6
0002d7 d137      	rcall	MODO_MENU
         	
         	; Si estamos en modo lista hay que ir al reproductor:
0002d8 9100 018b 	lds	r16, REPROD_FLAGS
0002da fd02      	sbrc	r16, REPR_MODO_LISTA
0002db cdb4      	rjmp	MODO_REPRODUCTOR	; Modo LISTA = 1
         	; No
         	
         	; Para redibujar toda la pantalla:
0002dc cf9b      	rjmp	MODO_EXPLORADOR_CAMBIA_DIRECT
         	
          modoexplo_sk6:	
0002dd 3002      	cpi	r16, PULS_SUBE_DIR
0002de f409      	brne	modoexplo_sk7
0002df c002      	rjmp	MODO_EXPL_SUB_DIRECT	
         
         
          modoexplo_sk7:	
         
         
         
         	
         
          modoexplo_nocmd:
         	; Rutina que se debe llamar aprox. cada 300 ms para
         	;  que se actualice el desplazamiento del nombre del fich
         	;  en el display:
0002e0 d0c1      	rcall	ACTUALIZA_DESPLAZ_FICH_LCD
         
         
0002e1 cfd5      	rjmp	MODO_EXPLORADOR_LOOP
         	
         
         
         
         ;==================================================================
         ;
         ;	  CMD: Subir un directorio
         ;
         ;==================================================================
          MODO_EXPL_SUB_DIRECT:
         	; Subir un directorio: 
         	; Si estamos en ROOT, ignorar:
0002e2 9100 00fd 	lds	r16, BPB_CLUS_DIR_RAIZ+0
0002e4 9110 0109 	lds	r17, FAT_DIRECT_ACTUAL+0
0002e6 1701      	cp	r16, r17
0002e7 f499      	brne	modoexplsubdir_si
0002e8 9100 00fe 	lds	r16, BPB_CLUS_DIR_RAIZ+1
0002ea 9110 010a 	lds	r17, FAT_DIRECT_ACTUAL+1
0002ec 1701      	cp	r16, r17
0002ed f469      	brne	modoexplsubdir_si
0002ee 9100 00ff 	lds	r16, BPB_CLUS_DIR_RAIZ+2
0002f0 9110 010b 	lds	r17, FAT_DIRECT_ACTUAL+2
0002f2 1701      	cp	r16, r17
0002f3 f439      	brne	modoexplsubdir_si
0002f4 9100 0100 	lds	r16, BPB_CLUS_DIR_RAIZ+3
0002f6 9110 010c 	lds	r17, FAT_DIRECT_ACTUAL+3
0002f8 1701      	cp	r16, r17
0002f9 f409      	brne	modoexplsubdir_si	
         
         	; Como estamos en root, ignorar:
0002fa cfbc      	rjmp	MODO_EXPLORADOR_LOOP
         
          modoexplsubdir_si:
         	; Subir un directorio:
0002fb e002      	ldi	r16, 2
0002fc 9300 0174 	sts	EXPLORER_ENTACT, r16
         
         	; Coger la entrada de ".."
0002fe e001      	ldi	r16, 1		; Peticion = coger datos
0002ff 9300 0111 	sts	FAT_PETICION,r16
000301 9100 0174 	lds	r16, EXPLORER_ENTACT
000303 9300 0112 	sts	FAT_PETICION_NUM_ENTR,r16
         	
000305 d3a4      	rcall	FAT_EXPLORA_DIRECTORIO
         	
         	; Poner corchetes al directorio:
000306 e50b      	ldi	r16, '['
000307 9300 0121 	sts	FATDE_FILENAME+0, r16
000309 e20e      	ldi	r16, '.'
00030a 9300 0122 	sts	FATDE_FILENAME+1, r16
00030c 9300 0123 	sts	FATDE_FILENAME+2, r16
00030e e50d      	ldi	r16, ']'
00030f 9300 0124 	sts	FATDE_FILENAME+3, r16
000311 e000      	ldi	r16, 0
000312 9300 0125 	sts	FATDE_FILENAME+4, r16
         
         	; Hacer como que pulsamos PLAY en ella:
000314 e003      	ldi	r16, PULS_PLAY
000315 9300 0178 	sts	COMANDO_USUARIO, r16
         	
000317 cfa5      	rjmp	modoexpl_seguncomando
         
         	
         
         ;==================================================================
         ;
         ;	  CMD: Siguiente fichero
         ;
         ;==================================================================
          MODO_EXPLO_SIG_FICHERO:
         	; Siguiente archivo / directorio:
000318 9100 0174 	lds	r16, EXPLORER_ENTACT
00031a 9110 0173 	lds	r17, EXPLORER_NUMENTS
00031c 9503      	inc	r16
         	
00031d 1710      	cp	r17, r16
00031e f408      	brsh	modo_explo_sig
         	
         	; Seleccionar primer directorio/fichero:
00031f e001      	ldi	r16, 0x01
          modo_explo_sig:	
000320 9300 0174 	sts	EXPLORER_ENTACT, r16
         
         
000322 cf63      	rjmp	MODO_EXPLORADOR_CAMBIA_FICH
         
         ;==================================================================
         ;
         ;	  CMD: Anterior fich
         ;
         ;==================================================================
          MODO_EXPLO_ANT_FICHERO:
         	; Siguiente archivo / directorio:
000323 9100 0174 	lds	r16, EXPLORER_ENTACT
         	
000325 3001      	cpi	r16, 0x01
000326 f419      	brne	modoexplantfich_ant
         	
         	; Si es el primero, ir al ultimo:
000327 9100 0173 	lds	r16, EXPLORER_NUMENTS
000329 1000      	cpse	r0,r0	; saltarse el DEC
         	
          modoexplantfich_ant:	
00032a 950a      	dec	r16
         		
00032b 9300 0174 	sts	EXPLORER_ENTACT, r16
         
00032d cf58      	rjmp	MODO_EXPLORADOR_CAMBIA_FICH
         
         ;==================================================================
         ;
         ;	  CMD: PLAY
         ;
         ;  Si es un fichero, reproduce
         ;  Si es un directorio, entrar:
         ;
         ;==================================================================
          MODO_EXPLO_PLAY:
00032e 9170 0118 	lds	r23, FATDE_ATTR
         	
000330 fd74      	sbrc	r23, 4
000331 c00f      	rjmp	modoexplplay_dir
         	
         	; Es un fichero:
         	; ---------------------
         	; antes de nada, guardar donde estabamos
000332 d23b      	rcall	SALVA_CONTEXT_EXPLORADOR
         
         	;  Poner como fichero seleccionado y reproducirlo:
000333 9100 0174 	lds	r16, EXPLORER_ENTACT
000335 9300 0179 	sts	REPROD_NUM_FICH_EN_DIR, r16
         	
         
000337 9100 0173 	lds	r16, EXPLORER_NUMENTS
000339 9300 017a 	sts	REPROD_NUM_FICHS_TOTAL, r16
         	
         	; Modo lista = NO
00033b 9100 018b 	lds	r16, REPROD_FLAGS
00033d 7f0b      	andi	r16, 0xFB
00033e 9300 018b 	sts	REPROD_FLAGS, r16
         	
000340 cd4f      	rjmp	MODO_REPRODUCTOR
         		
         	
         	; Es un directorio:
         	; ---------------------
          modoexplplay_dir:
         	; Si es "[.]" ignorar:
000341 9100 0122 	lds	r16, FATDE_FILENAME+1
000343 320e      	cpi	r16, '.'
000344 f429      	brne	modoexplplay_no_punto
         
000345 9100 0124 	lds	r16, FATDE_FILENAME+3
000347 3000      	cpi	r16, 0
000348 f409      	brne	modoexplplay_no_punto
         	; Si, es "." -> Ignorar
000349 c057      	rjmp	modoexplplay_fin
         
          modoexplplay_no_punto:
         	; Si el cluster es 0x00000000 es el raiz:
00034a 9100 0119 	lds	r16,  FATDE_CLUSTER+0
00034c 2300      	tst	r16
00034d f4e1      	brne	modoexplplay_no_root
00034e 9100 011a 	lds	r16,  FATDE_CLUSTER+1
000350 2300      	tst	r16
000351 f4c1      	brne	modoexplplay_no_root
000352 9100 011b 	lds	r16,  FATDE_CLUSTER+2
000354 2300      	tst	r16
000355 f4a1      	brne	modoexplplay_no_root
000356 9100 011c 	lds	r16,  FATDE_CLUSTER+3
000358 2300      	tst	r16
000359 f481      	brne	modoexplplay_no_root
         	
         	; Es el raiz:
00035a 9100 00fd 	lds	r16, BPB_CLUS_DIR_RAIZ+0	
00035c 9300 0119 	sts	FATDE_CLUSTER+0, r16
00035e 9100 00fe 	lds	r16, BPB_CLUS_DIR_RAIZ+1
000360 9300 011a 	sts	FATDE_CLUSTER+1, r16
000362 9100 00ff 	lds	r16, BPB_CLUS_DIR_RAIZ+2	
000364 9300 011b 	sts	FATDE_CLUSTER+2, r16
000366 9100 0100 	lds	r16, BPB_CLUS_DIR_RAIZ+3	
000368 9300 011c 	sts	FATDE_CLUSTER+3, r16
         	
         
          modoexplplay_no_root:
         	; Poner como directorio actual:
00036a 9100 0119 	lds	r16,  FATDE_CLUSTER+0
00036c 9300 0109 	sts	FAT_DIRECT_ACTUAL+0 , r16
00036e 9100 011a 	lds	r16,  FATDE_CLUSTER+1
000370 9300 010a 	sts	FAT_DIRECT_ACTUAL+1 , r16
000372 9100 011b 	lds	r16,  FATDE_CLUSTER+2
000374 9300 010b 	sts	FAT_DIRECT_ACTUAL+2 , r16
000376 9100 011c 	lds	r16,  FATDE_CLUSTER+3
000378 9300 010c 	sts	FAT_DIRECT_ACTUAL+3 , r16
         
         
         	; Si es "[..]" recuperar posicion en ese directorio:
00037a 9100 0122 	lds	r16, FATDE_FILENAME+1
00037c 320e      	cpi	r16, '.'
00037d f4b1      	brne	modoexplplay_no_puntpunt		
00037e 9100 0123 	lds	r16, FATDE_FILENAME+2
000380 320e      	cpi	r16, '.'
000381 f491      	brne	modoexplplay_no_puntpunt		
000382 9100 0125 	lds	r16, FATDE_FILENAME+4
000384 3000      	cpi	r16, 0
000385 f471      	brne	modoexplplay_no_puntpunt		
         	
         	; Es ".."
000386 d7a5      	rcall	HAB_EXTRAM
         	
000387 91b0 4dd7 	lds	XH, PILA_DIRECTORIOS_PTR+0
000389 91a0 4dd8 	lds	XL, PILA_DIRECTORIOS_PTR+1
         	
00038b 9711      	sbiw	XL, 1
00038c 910c      	ld	r16, X
00038d 9300 0174 	sts	EXPLORER_ENTACT, r16
         
00038f 93b0 4dd7 	sts	PILA_DIRECTORIOS_PTR+0, XH
000391 93a0 4dd8 	sts	PILA_DIRECTORIOS_PTR+1, XL
         
         
         	; Seguir por alli, pero no sobreescribir el num. de 
         	;  fichero seleccionado
000393 cee7      	rjmp	MODO_EXPLORADOR_CAMBIA_DIRECT2
         	
          modoexplplay_no_puntpunt:
000394 d797      	rcall	HAB_EXTRAM
         	; Se ha entrado en un directorio: Guardar posicion actual
         	;  en una pila para luego saber donde ibamos:
000395 91b0 4dd7 	lds	XH, PILA_DIRECTORIOS_PTR+0
000397 91a0 4dd8 	lds	XL, PILA_DIRECTORIOS_PTR+1
         	
000399 9100 0174 	lds	r16, EXPLORER_ENTACT
00039b 930c      	st	X, r16
00039c 9611      	adiw	XL, 1
         
00039d 93b0 4dd7 	sts	PILA_DIRECTORIOS_PTR+0, XH
00039f 93a0 4dd8 	sts	PILA_DIRECTORIOS_PTR+1, XL
         	
         
          modoexplplay_fin:		
0003a1 ced6      	rjmp	MODO_EXPLORADOR_CAMBIA_DIRECT
         	
         	
         
         ; -------------------------------------------------
         ; Rutina que se debe llamar aprox. cada 300 ms para
         ;  que se actualice el desplazamiento del nombre del fich
         ;  en el display:
         ; -------------------------------------------------
          ACTUALIZA_DESPLAZ_FICH_LCD:	
         	; El texto debe deslizarse??
         	; -------------------------------------------------
0003a2 e0b1      	ldi	XH, high( FATDE_FILENAME )
0003a3 e2a1      	ldi	XL,  low( FATDE_FILENAME )
0003a4 d795      	rcall	STRLEN
         
         	; Guardar long. de cadena en r1 para luego
0003a5 2e10      	mov	r1, r16	
         	
0003a6 3105      	cpi	r16, ANCHO_LCD+1
0003a7 f40c      	brge	modo_explo_proc_deslizamiento	
         
         	; No hay que deslizar:
          ve_MODO_EXPLORADOR_LOOP:
0003a8 9508      	ret
         
         	
          modo_explo_proc_deslizamiento:
         	; Inc. contador para retardo:
0003a9 9100 0177 	lds	r16, EXPLORER_LCD_RETARDO
         	
0003ab 3008      	cpi	r16, VALOR_EXPL_LCD_RET
0003ac f019      	breq	modo_explo_desliz_noinccnt	; Ya esta deslizando!
         	
0003ad 9503      	inc	r16
0003ae 9300 0177 	sts	EXPLORER_LCD_RETARDO, r16
          modo_explo_desliz_noinccnt:
         
         	; Si aun no ha llegado a su valor, no mover:
0003b0 3008      	cpi	r16, VALOR_EXPL_LCD_RET
0003b1 f7b1      	brne	ve_MODO_EXPLORADOR_LOOP
         	
         	; Deslizar texto en el sentido actual:
0003b2 9110 0176 	lds	r17, EXPLORER_LCD_SENTIDO
         	
0003b4 9100 0175 	lds	r16, EXPLORER_LCD_OFFSET
0003b6 0f01      	add	r16, r17
0003b7 9300 0175 	sts	EXPLORER_LCD_OFFSET, r16
         	
         	; Si llega a un borde, cambiar el sentido de deslizamiento:
         	; Bordes: 0 y STRLEN(S)-ANCHO_LCD
0003b9 2300      	tst	r16
0003ba f029      	breq	modoexpl_cambia_sentido
         
         	; r1 era la longitud del texto:
0003bb 2d11      	mov	r17, r1
0003bc 5114      	subi	r17, ANCHO_LCD
0003bd 1701      	cp	r16, r17
0003be f009      	breq	modoexpl_cambia_sentido
         
         	; Pues nada, a seguir	
         	
0003bf 9508      	ret
         	
         
          modoexpl_cambia_sentido:
         	; hacer q se detenga un momento en los bordes:
0003c0 e004      	ldi	r16, VALOR_EXPL_LCD_RET / 2
0003c1 9300 0177 	sts	EXPLORER_LCD_RETARDO, r16
         
0003c3 9110 0176 	lds	r17, EXPLORER_LCD_SENTIDO
0003c5 9511      	neg	r17	
0003c6 9310 0176 	sts	EXPLORER_LCD_SENTIDO, r17
         
0003c8 9508      	ret
         
         
         
         ; ---------------------------------------------------------
         ;    ACTUALIZA_NOMBRE_FICH_LCD
         ;
         ;  Pone el nombre del fich. en display, con su desplazamiento
         ; ---------------------------------------------------------
          ACTUALIZA_NOMBRE_FICH_LCD:
         	; No borrar LCD para q no parpadee ;-)
0003c9 d767      	rcall	DESHAB_EXTRAM
         
         	; Primera linea: El nombre del fich. seleccionado.
         	; --------------------------------------------------
0003ca e000      	ldi	r16, 0
0003cb d699      	rcall	LCD_SET_CURSOR_POS_R16
0003cc d6d5      	rcall	LCD_BORRAR_LINEA
         
0003cd e000      	ldi	r16, 0
0003ce d696      	rcall	LCD_SET_CURSOR_POS_R16
         
0003cf e0b1      	ldi	XH, high( FATDE_FILENAME )
0003d0 e2a1      	ldi	XL,  low( FATDE_FILENAME )
0003d1 9110 0175 	lds	r17, EXPLORER_LCD_OFFSET
0003d3 e124      	ldi	r18, ANCHO_LCD
0003d4 d6b5      	rcall	LCD_ESC_X_OFF_R17_MAX_R18
         	
0003d5 9508      	ret
         
         
         ; ------------------------------------
         ; PREPARAR_DATOS_LCD_FICHERO
         ;
         ;  Usado por el explorador y el reproductor:
         ;   Inicia valores de desplazamiento de texto 
         ;  , pone corchetes a directorios, etc...
         ;
         ;  Borra LCD y pone en 2º linea: "N/M"
         ; ------------------------------------
          PREPARAR_DATOS_LCD_FICHERO:	
         	; Si es directorio, poner corchetes:
0003d6 9170 0118 	lds	r23, FATDE_ATTR
         	
0003d8 ff74      	sbrs	r23, 4
0003d9 c01c      	rjmp	modoexpl_no_corchetes
         	
         	; Si es directorio, poner corchetes:
         	; ------------------------------------
0003da e0b1      	ldi	XH, high( FATDE_FILENAME )
0003db e2a1      	ldi	XL,  low( FATDE_FILENAME )
0003dc d75d      	rcall	STRLEN
         	
0003dd 2e10      	mov	r1, r16
         	
         	; Mover hacia la derecha una posicion:
0003de e0d1      	ldi	YH, high( FATDE_FILENAME )
0003df e2c1      	ldi	YL,  low( FATDE_FILENAME )
         	
0003e0 2400      	clr	r0
0003e1 0dc1      	add	YL, r1
0003e2 1dd0      	adc	YH, r0
0003e3 2d21      	mov	r18, r1
0003e4 9523      	inc	r18
          modoexpl_corch_loop:
0003e5 8108      	ld	r16, Y
0003e6 8309      	std	Y+1, r16
         	
0003e7 50c1      	subi	YL, 1
0003e8 09d0      	sbc	YH, r0
         
0003e9 952a      	dec	r18
0003ea f7d1      	brne	modoexpl_corch_loop
         	
         	
0003eb e0b1      	ldi	XH, high( FATDE_FILENAME )
0003ec e2a1      	ldi	XL,  low( FATDE_FILENAME )
         
0003ed e50b      	ldi	r16, '['
0003ee 930d      	st	X+, r16
         	
0003ef 2400      	clr	r0
0003f0 0da1      	add	XL, r1
0003f1 1db0      	adc	XH, r0
         	
0003f2 e50d      	ldi	r16, ']'
0003f3 930d      	st	X+, r16
         	
0003f4 e000      	ldi	r16, 0x00
0003f5 930d      	st	X+, r16
         	
          modoexpl_no_corchetes:
         	; Iniciar valores para desplazamiento en display:
0003f6 2700      	clr	r16
0003f7 9300 0175 	sts	EXPLORER_LCD_OFFSET, r16
0003f9 9300 0177 	sts	EXPLORER_LCD_RETARDO,r16
         	
0003fb e001      	ldi	r16, 1	; Empezar hacia la derecha
0003fc 9300 0176 	sts	EXPLORER_LCD_SENTIDO, r16
         
         	
         	; Borrar display del todo al cambiar de fichero:
0003fe d732      	rcall	DESHAB_EXTRAM
0003ff d625      	rcall	LCD_BORRAR
         
         
000400 9508      	ret
         
         
         ; ------------------------------------------------------------
         ;  PREPARA_TMR1_OVR_300ms
         ;
         ; Preparar TMR1 para que se desborde aprox. cada 0.3 segs:
         ; ------------------------------------------------------------
          PREPARA_TMR1_OVR_300ms:
         	; Divisor a CK/64
000401 2700      	clr	r16		; Modo normal
000402 bd0f      	out	TCCR1A, r16
         
         	; Seguir contando:
000403 e003      	ldi	r16, 0x03
000404 bd0e      	out	TCCR1B, r16
         
         	; Contador de 8 us cada unidad:
         	; Poner en el contador 0xFFFF - FRECUENCIA_DISPLAY(us)/8
000405 2700      	clr	r16
000406 bd0d      	out	TCNT1H, r16
000407 bd0c      	out	TCNT1L, r16
         
000408 e700      	ldi	r16, high ( FRECUENCIA_DISPLAY )
000409 bd0b      	out	OCR1AH, r16
00040a e000      	ldi	r16,  low ( FRECUENCIA_DISPLAY )
00040b bd0a      	out	OCR1AL, r16
         	
         	; Quitar posible flag de desborde:
00040c ee08      	ldi	r16, 0xE8
00040d bf08      	out	TIFR, r16
         	
00040e 9508      	ret	
         
         
         
         
         ; -----------------------------------------------------------
         ;   	MODO MENU
         ;
         ;  Llamado con RCALL desde el modo explorador
         ;
         ;
         ; 	Es un menu con opciones y configuraciones, etc...
         ;
         ;
         ; -----------------------------------------------------------
          MODO_MENU:
00040f e095      	ldi	r25, 5
000410 d3f8      	rcall	RETARDO_R25x25ms
         	
         	
         	; Seleccionar primera opcion:
000411 e001      	ldi	r16, 0x01
000412 9300 018c 	sts	MENU_OPCION,r16
         
         
         	; Reconstruir pantalla:
         	; Primera linea: Opcion actual
         	; Segunda linea: Posicion dentro del menu, teclas usables.
          MODO_MENU_LOOP:
         	; Primera linea:
         	; ------------------------------
000414 d610      	rcall	LCD_BORRAR
         	
000415 9100 018c 	lds	r16, MENU_OPCION
         	
000417 3001      	cpi	r16, 1
000418 f419      	brne	mnu_no_1
         	; OPCION 1
000419 e1f5      	ldi	ZH, high( MNU_1 * 2)
00041a efe4      	ldi	ZL,  low( MNU_1 * 2)
00041b c024      	rjmp	modomnu_esc_lin
          mnu_no_1:
00041c 3002      	cpi	r16, 2
00041d f419      	brne	mnu_no_2
         	; OPCION 2
00041e e1f6      	ldi	ZH, high( MNU_2 * 2)
00041f e0e6      	ldi	ZL,  low( MNU_2 * 2)
000420 c01f      	rjmp	modomnu_esc_lin
          mnu_no_2:
000421 3003      	cpi	r16, 3
000422 f459      	brne	mnu_no_3
         	; OPCION 3: Bajos
000423 9110 018b 	lds	r17, REPROD_FLAGS
000425 e006      	ldi	r16, 6		; Cuadro sin marcar
000426 fd11      	sbrc	r17, REPR_FLAG_BASS
000427 e007      	ldi	r16, 7		; Cuadro con marca
000428 d60b      	rcall	LCD_TX_DATO
000429 e200      	ldi	r16, ' '
00042a d609      	rcall	LCD_TX_DATO
         
00042b e1f6      	ldi	ZH, high( MNU_3 * 2)
00042c e1e8      	ldi	ZL,  low( MNU_3 * 2)
00042d c012      	rjmp	modomnu_esc_lin
          mnu_no_3:
00042e 3004      	cpi	r16, 4
00042f f459      	brne	mnu_no_4
         	; OPCION 4: Sorround
000430 9110 018b 	lds	r17, REPROD_FLAGS
000432 e006      	ldi	r16, 6		; Cuadro sin marcar
000433 fd10      	sbrc	r17, REPR_FLAG_SORROUND
000434 e007      	ldi	r16, 7		; Cuadro con marca
000435 d5fe      	rcall	LCD_TX_DATO
000436 e200      	ldi	r16, ' '
000437 d5fc      	rcall	LCD_TX_DATO
         
000438 e1f6      	ldi	ZH, high( MNU_4 * 2)
000439 e2e6      	ldi	ZL,  low( MNU_4 * 2)
00043a c005      	rjmp	modomnu_esc_lin
          mnu_no_4:
00043b 3005      	cpi	r16, 5
00043c f419      	brne	mnu_no_5
         	; OPCION 5
00043d e1f6      	ldi	ZH, high( MNU_5 * 2)
00043e e3e8      	ldi	ZL,  low( MNU_5 * 2)
00043f c000      	rjmp	modomnu_esc_lin
          mnu_no_5:
         
         	
         	
          modomnu_esc_lin:
000440 d618      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
         
          modomnu_seglin:
         	; Segunda linea:
         	; ------------------------------
000441 e400      	ldi	r16, 0x40
000442 d622      	rcall	LCD_SET_CURSOR_POS_R16
         	
         	; Escribir numero de opcion con respecto al total:
000443 e0b0      	ldi	XH, high (STR_BUF)
000444 e6a0      	ldi	XL,  low (STR_BUF)
         	
000445 9120 018c 	lds	r18, MENU_OPCION
000447 d3ca      	rcall	BYTE2ASCII_R18
         	
000448 e20f      	ldi	r16, '/'
000449 930d      	st	X+, r16
         
00044a e025      	ldi	r18, NUM_MENUS
00044b d3c6      	rcall	BYTE2ASCII_R18
         
00044c e200      	ldi	r16, ' '
00044d 930d      	st	X+, r16
00044e e70f      	ldi	r16, 0x7F
00044f 930d      	st	X+, r16
000450 e70e      	ldi	r16, 0x7E
000451 930d      	st	X+, r16
         		
000452 d3fb      	rcall	CERO_2_X
         
         	
000453 e0b0      	ldi	XH, high (STR_BUF)
000454 e6a0      	ldi	XL,  low (STR_BUF)
000455 d62e      	rcall	LCD_ESCRIBE_X
         		
         	
         	; Retardo de cada ciclo: 300 ms aprox
         	; ------------------------------------------
000456 e09e      	ldi	r25, 14
000457 d3b1      	rcall	RETARDO_R25x25ms
         	
         		
         	; Algun comando del teclado / mando a distancia??
         	; -------------------------------------------------
000458 d100      	rcall	LEE_PULS_Y_IR
         
000459 9100 0178 	lds	r16, COMANDO_USUARIO	; Del tecl o IR
00045b 2300      	tst	r16
00045c f179      	breq	modomenu_nocmd
         	
00045d e010      	ldi	r17, 0x00
00045e 9310 0178 	sts	COMANDO_USUARIO, r17
         	
         	;  Segun comando:
000460 3005      	cpi	r16, PULS_ALANTE
000461 f441      	brne	modomenu_sk1
         	
         	; Siguiente linea
000462 9120 018c 	lds	r18, MENU_OPCION
000464 3025      	cpi	r18, NUM_MENUS
000465 f021      	breq	modomenu_sk1
000466 9523      	inc	r18
000467 9320 018c 	sts	MENU_OPCION, r18
000469 c022      	rjmp	modomenu_nocmd
         		
          modomenu_sk1:	
00046a 3006      	cpi	r16, PULS_ATRAS
00046b f441      	brne	modomenu_sk2
         	
         	; Anterior
00046c 9120 018c 	lds	r18, MENU_OPCION
00046e 3021      	cpi	r18, 1
00046f f021      	breq	modomenu_sk2
000470 952a      	dec	r18
000471 9320 018c 	sts	MENU_OPCION, r18
000473 c018      	rjmp	modomenu_nocmd
         		
          modomenu_sk2:	
000474 3004      	cpi	r16, PULS_STOP
000475 f409      	brne	modomenu_sk3
         	
         	; Salir del modo menu
000476 9508      	ret
         		
          modomenu_sk3:	
000477 3003      	cpi	r16, PULS_PLAY
000478 f009      	breq	modomenu_nosk3
000479 c012      	rjmp	modomenu_sk4
         	
         	; EJECUTAR OPCION:
         	; ---------------------------
          modomenu_nosk3:	
00047a 9120 018c 	lds	r18, MENU_OPCION
00047c 3021      	cpi	r18, 0x01
00047d f409      	brne	modomnu_sel_sk1
00047e c00e      	rjmp	MODO_MENU_SELEC_1
          modomnu_sel_sk1:
00047f 3022      	cpi	r18, 0x02
000480 f409      	brne	modomnu_sel_sk2
000481 c00b      	rjmp	MODO_MENU_SELEC_2
          modomnu_sel_sk2:
000482 3023      	cpi	r18, 0x03
000483 f409      	brne	modomnu_sel_sk3
000484 c04d      	rjmp	MODO_MENU_SELEC_3
          modomnu_sel_sk3:
000485 3024      	cpi	r18, 0x04
000486 f409      	brne	modomnu_sel_sk4
000487 c051      	rjmp	MODO_MENU_SELEC_4
          modomnu_sel_sk4:
000488 3025      	cpi	r18, 0x05
000489 f409      	brne	modomnu_sel_sk5
00048a c055      	rjmp	MODO_MENU_SELEC_5
          modomnu_sel_sk5:
         
         
00048b cf88      	rjmp	MODO_MENU_LOOP
         		
          modomenu_sk4:	
         	
         	
         	
         
          modomenu_nocmd:
00048c cf87      	rjmp	MODO_MENU_LOOP
         	
         	
         ; ---------------------------------------------
         ;   Seleccionado elemento del menu
         ;
         ;  Reproducir en modo lista todo el directorio 
         ;   seleccionado en modo aleatorio
         ; ---------------------------------------------
          MODO_MENU_SELEC_2:
         
         ; ---------------------------------------------
         ;   Seleccionado elemento del menu
         ;
         ;  Reproducir en modo lista todo el directorio 
         ;   seleccionado:
         ; ---------------------------------------------
          MODO_MENU_SELEC_1:
         	; Estamos en un directorio?
00048d d8e4      	rcall	ES_DIRENTRY_DIRECT_VALIDO
00048e f5d8      	brcc	pon_error_no_dir
         
         	; antes de nada, guardar donde estabamos
00048f d0de      	rcall	SALVA_CONTEXT_EXPLORADOR
         	
         
000490 d8fb      	rcall	FORMAR_LISTA_REPRODUCCION
         
         ;	ldi	YH, high (LST_REPR_LISTA)
         ;	ldi	YL,  low (LST_REPR_LISTA)
         ;	rjmp	FAT_DEBUG_DUMP_Y
         	
         	; Poner modo lista y salir con RET, de donde vinimos
         	;  ya pondra en modo reproduccion:
         
         	; Guardar num. de fichs en lista:
000491 9100 4b41 	lds	r16, LST_REPR_CUANTOS
000493 9300 017a 	sts	REPROD_NUM_FICHS_TOTAL, r16
         	
         	; Si no hay, dar error:
000495 2300      	tst	r16
000496 f171      	breq	pon_error_no_mp3s	
         
         	; Si hay ficheros
         	
         	; Formar la lista de orden. En este caso secuencial: 1, 2,...
000497 e4bb      	ldi	XH, high ( LST_REPR_ORDEN )
000498 e4a2      	ldi	XL,  low ( LST_REPR_ORDEN )
000499 e001      	ldi	r16, 0x01
         	
00049a d691      	rcall	HAB_EXTRAM
         	
          modomn1_haz_orden_lp:
00049b 930d      	st	X+, r16
00049c 9503      	inc	r16
00049d f7e9      	brne	modomn1_haz_orden_lp
         		
         	; Poner flag de modo lista	
00049e 9100 018b 	lds	r16, REPROD_FLAGS
0004a0 6004      	ori	r16, 0x04	; MODO LISTA
0004a1 9300 018b 	sts	REPROD_FLAGS, r16
         		
         	; Empezar por primer fichero:
0004a3 e001      	ldi	r16, 0x01	
0004a4 9300 0179 	sts	REPROD_NUM_FICH_EN_DIR, r16
         	
         	; Si era aleatorio, desordenar la lista de orden:
0004a6 9120 018c 	lds	r18, MENU_OPCION
0004a8 3022      	cpi	r18, 2
0004a9 f009      	breq	modomnu_aleatorio
         	
0004aa 9508      	ret
         
         ; Aleatorizar la lista LST_REPR_ORDEN
         ;
         ;  Son REPROD_NUM_FICHS_TOTAL valores
         ; 
         ; --------------------------------------------------------
          modomnu_aleatorio:
0004ab 9120 017a 	lds	r18, REPROD_NUM_FICHS_TOTAL
         
         	; X va apuntando a los valores de orden
         	; Y va apuntando a valores x ahi en la RAM, 
         	;   para hacer algo medio pseudoaleatorio, 
         	;   a la vez q se XORea con TCNT0
0004ad e4bb      	ldi	XH, high ( LST_REPR_ORDEN )
0004ae e4a2      	ldi	XL,  low ( LST_REPR_ORDEN )
         	
0004af e0d4      	ldi	YH, high ( SECTOR_BUFFER )
0004b0 e0c0      	ldi	YL,  low ( SECTOR_BUFFER )
0004b1 2400      	clr	r0
0004b2 b612      	in	r1, TCNT0
0004b3 0dc1      	add	YL, r1
0004b4 1dd0      	adc	YH, r0
         	
         
0004b5 d676      	rcall	HAB_EXTRAM
         	
         	; Para el modulo:
0004b6 9020 017a 	lds	r2, REPROD_NUM_FICHS_TOTAL
         		
         	; Aleatoriza entrada:
          modomnu_aleat_lp:
0004b8 d66a      	rcall	GENERAR_PSEUDOALEAT 	; En r16
0004b9 d66d      	rcall	R16_MODULO_R2
         
         	; Intercambiar LST_REPR_ORDEN[ R16 ] con [ X ]
         	; ---------------------------------------------
0004ba e4fb      	ldi	ZH, high ( LST_REPR_ORDEN )
0004bb e4e2      	ldi	ZL,  low ( LST_REPR_ORDEN )
0004bc 0fe0      	add	ZL, r16
0004bd 1df0      	adc	ZH, r0
         	
         	; Intercambiar X y Z
0004be 910c      	ld	r16, X
0004bf 8110      	ld	r17, Z
0004c0 8300      	st	Z, r16
0004c1 931d      	st	X+, r17
         	
         	; Y asi hasta el final:
0004c2 952a      	dec	r18
0004c3 f7a1      	brne	modomnu_aleat_lp
         
         
0004c4 9508      	ret
         
         
         
         
          pon_error_no_mp3s:
0004c5 d66b      	rcall	DESHAB_EXTRAM
         	
0004c6 d55e      	rcall	LCD_BORRAR
         	
0004c7 e1f5      	ldi	ZH, high( STR_NO_MP3s * 2)
0004c8 eee2      	ldi	ZL,  low( STR_NO_MP3s* 2)
         	
0004c9 c004      	rjmp	pon_error_sig
         
         	
          pon_error_no_dir:
0004ca d666      	rcall	DESHAB_EXTRAM
         	
0004cb d559      	rcall	LCD_BORRAR
         	
0004cc e1f5      	ldi	ZH, high( STR_NO_DIR * 2)
0004cd ecee      	ldi	ZL,  low( STR_NO_DIR * 2)
         
          pon_error_sig:
0004ce d58a      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
0004cf e298      	ldi	r25, 40
0004d0 d338      	rcall	RETARDO_r25x25ms
         
         
         	; Salir del modo MENU:
0004d1 9508      	ret
         	
         
         ; ---------------------------------------------
         ;   Seleccionado elemento del menu
         ;
         ;   Bajos
         ; ---------------------------------------------
          MODO_MENU_SELEC_3:
0004d2 9100 018b 	lds	r16, REPROD_FLAGS
0004d4 e012      	ldi	r17, ( 1 << REPR_FLAG_BASS )
0004d5 2701      	eor	r16, r17
0004d6 9300 018b 	sts	REPROD_FLAGS, r16
         
0004d8 cf3b      	rjmp	MODO_MENU_LOOP
         
         ; ---------------------------------------------
         ;   Seleccionado elemento del menu
         ;
         ;   Sorround
         ; ---------------------------------------------
          MODO_MENU_SELEC_4:
0004d9 9100 018b 	lds	r16, REPROD_FLAGS
0004db e011      	ldi	r17, ( 1 << REPR_FLAG_SORROUND )
0004dc 2701      	eor	r16, r17
0004dd 9300 018b 	sts	REPROD_FLAGS, r16
         	
         	
0004df cf34      	rjmp	MODO_MENU_LOOP
         
         
         ; ---------------------------------------------
         ;   Seleccionado elemento del menu
         ;
         ;   Probar IR:
         ; ---------------------------------------------
          MODO_MENU_SELEC_5:
         	; Ir mostrando el texto correspondiente a la tecla
         	;   de la tabla IR_TABLA_COD_CMDS y grabar en EEP. nuevo codigo
         	
0004e0 e040      	ldi	r20, 0	; r20 = indice de tecla actual
         	
         		
          modomnu5_lp:
0004e1 d543      	rcall	LCD_BORRAR
         	
         	; Obtener texto de la tecla actual 
0004e2 e1f8      	ldi	ZH, high (IR_TABLA_COD_CMDS*2)
0004e3 ebe4      	ldi	ZL,  low (IR_TABLA_COD_CMDS*2)
         	
0004e4 2400      	clr	r0	
0004e5 0fe4      	add	ZL, r20
0004e6 1df0      	adc	ZH, r0
         	
         	; Cargar codigo de la tecla actual:
0004e7 95c8      	lpm
         	
         	; Segun el codigo, poner su nombre:	
0004e8 e0fa      	ldi	ZH, high (TABLA_CODS_TXTS*2)
0004e9 e6e8      	ldi	ZL,  low (TABLA_CODS_TXTS*2)
         	
0004ea 2d00      	mov	r16, r0
0004eb 0f00      	lsl	r16
0004ec 2400      	clr	r0
0004ed 0fe0      	add	ZL, r16
0004ee 1df0      	adc	ZH, r0
         	
0004ef 95c8      	lpm
0004f0 2d10      	mov	r17, r0
0004f1 9631      	adiw	ZL, 1
0004f2 95c8      	lpm
0004f3 2df0      	mov	ZH, r0
0004f4 2fe1      	mov	ZL, r17
         	
         	; Poner texto:
0004f5 d563      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
0004f6 e0b0      	ldi	XH, high ( STR_BUF )	
0004f7 e6a0      	ldi	XL,  low ( STR_BUF )	
         	
0004f8 e200      	ldi	r16, ' '
0004f9 930d      	st	X+, r16
0004fa 930d      	st	X+, r16
         	
0004fb 2f24      	mov	r18, r20
0004fc d315      	rcall	BYTE2ASCII_R18
         	
0004fd d350      	rcall	CERO_2_X
         	
0004fe e0b0      	ldi	XH, high ( STR_BUF )	
0004ff e6a0      	ldi	XL,  low ( STR_BUF )	
000500 d583      	rcall	LCD_ESCRIBE_X
         
         	
         	; Hay una nueva?
000501 9100 0193 	lds	r16, IR_CODE_FINAL+0
000503 2300      	tst	r16
000504 f409      	brne	monomnu5_puede_ir
000505 c014      	rjmp	modomnu5_no_ir
         	
          monomnu5_puede_ir:	
000506 9100 0194 	lds	r16, IR_CODE_FINAL+1
000508 2300      	tst	r16
000509 f081      	breq	modomnu5_no_ir
         	
         	; Si, hay un nuevo codigo, cogerlo y grabarlo en eeprom:
00050a e0b0      	ldi	XH, 0x00
00050b e1a0      	ldi	XL, 0x10	
00050c 2f04      	mov	r16, r20
00050d 0f00      	lsl	r16
00050e 0fa0      	add	XL, r16
         	
00050f 9100 0193 	lds	r16, IR_CODE_FINAL+0
000511 d758      	rcall	GRB_EEP
000512 9100 0194 	lds	r16, IR_CODE_FINAL+1
000514 d755      	rcall	GRB_EEP
         
         	; Y borrarlo ya:
000515 2700      	clr	r16
000516 9300 0193 	sts	IR_CODE_FINAL+0, r16
000518 9300 0194 	sts	IR_CODE_FINAL+1, r16	
         	
          modomnu5_no_ir:
         	; 2º linea: Poner codigo de tecla de eeprom:
00051a e400      	ldi	r16, 0x40
00051b d549      	rcall	LCD_SET_CURSOR_POS_R16
         	
         	; Posicion en eeprom de los codigos
00051c e0b0      	ldi	XH, 0x00
00051d e1a0      	ldi	XL, 0x10	
00051e 2f04      	mov	r16, r20
00051f 0f00      	lsl	r16
000520 0fa0      	add	XL, r16
         	
000521 d740      	rcall	LEE_EEPROM
000522 d547      	rcall	LCD_ESCRIBE_R16_HEX
000523 d73e      	rcall	LEE_EEPROM
000524 d545      	rcall	LCD_ESCRIBE_R16_HEX
         
         
         
         	; Retardo en cada ciclo:
000525 e194      	ldi	r25, 20
000526 d2e2      	rcall	RETARDO_R25x25ms
         
         	
         	; Procesar siguiente tecla y acabar:
000527 d698      	rcall	LEE_PULSADORES
000528 2300      	tst	r16
000529 f049      	breq	modomnu5_fin
         	
00052a 3004      	cpi	r16, PULS_STOP
00052b f409      	brne	modomnu5_sk1	
          modomnu5_salir:	
00052c cee7      	rjmp	MODO_MENU_LOOP	; Salir
         	
          modomnu5_sk1:
00052d 3003      	cpi	r16, PULS_PLAY
00052e f421      	brne	modomnu5_sk2	
         	
         	; Pasar a siguiente tecla:
00052f 9543      	inc	r20
000530 304e      	cpi	r20, (FIN_IR_TABLA_COD_CMDS- IR_TABLA_COD_CMDS)*2
000531 f3d1      	breq	modomnu5_salir
         
000532 cfae      	rjmp	modomnu5_lp
          modomnu5_sk2:
         
         
         
         
         
          modomnu5_fin:	
000533 cfad      	rjmp	modomnu5_lp
         	
         	
         
         
          TABLA_CODS_TXTS:
         ;.equ	PULS_VOL_MAS	= 8
         ;.equ	PULS_VOL_MENOS	= 7
         ;.equ	PULS_ATRAS	= 6
         ;.equ	PULS_ALANTE	= 5
         ;.equ	PULS_STOP	= 4
         ;.equ	PULS_PLAY	= 3
         ; PULS_SUBE_DIR =2
         
          	.dw	0	; 0
000534 0000
          	.dw	0	; 1
000535 0000
          	.dw	str_SUBDIR	* 2
000536 0aa0
          	.dw	str_PLAY 	* 2
000537 0a7a
          	.dw	str_STOP 	* 2
000538 0a80
          	.dw	str_ALAN 	* 2
000539 0a86
          	.dw	str_ATRAS 	* 2
00053a 0a8e
          	.dw	str_VOLMEN 	* 2
00053b 0a9a
          	.dw	str_VOLMAS 	* 2
00053c 0a94
         
         
00053d      str_PLAY:	.db	"Play", 0,0
00053d 6c50
00053e 7961
00053f 0000
000540      str_STOP:	.db	"Stop", 0,0
000540 7453
000541 706f
000542 0000
000543      str_ALAN:	.db	"Alante", 0,0
000543 6c41
000544 6e61
000545 6574
000546 0000
000547      str_ATRAS:	.db	"Atras", 0
000547 7441
000548 6172
000549 0073
00054a      str_VOLMAS:	.db	"Vol +", 0
00054a 6f56
00054b 206c
00054c 002b
00054d      str_VOLMEN:	.db	"Vol -", 0
00054d 6f56
00054e 206c
00054f 002d
000550      str_SUBDIR:	.db 	"Subir directorio", 0,0
000550 7553
000551 6962
000552 2072
000553 6964
000554 6572
000555 7463
000556 726f
000557 6f69
000558 0000
         	
         ; --------------------------------------------------------
         ; Prepara el comando correspondiente en COMANDO_USUARIO
         ;  si hay alguno, a traves del teclado o del mando.
         ; --------------------------------------------------------
          LEE_PULS_Y_IR:
000559 d666      	rcall	LEE_PULSADORES
         	
00055a 2300      	tst	r16
00055b f011      	breq	leepuls_no
         	
00055c 9300 0178 	sts	COMANDO_USUARIO, r16
         
          leepuls_no:	
00055e 9100 0190 	lds	r16, IR_TIMEOUT
000560 2300      	tst	r16
000561 f051      	breq	leepuls_lee_ir_ok
         	
000562 950a      	dec	r16
000563 930f      	push	r16
         
000564 d6cc      	rcall	IR_PROCESA_CODIGO	; Del IR:
         
000565 910f      	pop	r16
000566 9300 0190 	sts	IR_TIMEOUT, r16
         		
000568 e000      	ldi	r16, 0x00
000569 9300 0178 	sts	COMANDO_USUARIO, r16
         	
00056b 9508      	ret
         	
         	
          leepuls_lee_ir_ok:
00056c d6c4      	rcall	IR_PROCESA_CODIGO	; Del IR:
         
00056d 9508      	ret
         
         
         ; ------------------------------------------------------------
         ; Guarda el direct. actual y posicion:
         ; ------------------------------------------------------------
          SALVA_CONTEXT_EXPLORADOR:
00056e d5bd      	rcall	HAB_EXTRAM
         
00056f 9100 0109 	lds	r16, 	FAT_DIRECT_ACTUAL+0
000571 9300 4dd2 	sts	CONTEXT_EXPL_DIR+0, r16
000573 9100 010a 	lds	r16, 	FAT_DIRECT_ACTUAL+1
000575 9300 4dd3 	sts	CONTEXT_EXPL_DIR+1, r16
000577 9100 010b 	lds	r16, 	FAT_DIRECT_ACTUAL+2
000579 9300 4dd4 	sts	CONTEXT_EXPL_DIR+2, r16
00057b 9100 010c 	lds	r16, 	FAT_DIRECT_ACTUAL+3
00057d 9300 4dd5 	sts	CONTEXT_EXPL_DIR+3, r16
         	
00057f 9100 0174 	lds	r16, EXPLORER_ENTACT
000581 9300 4dd6 	sts	CONTEXT_EXPL_ENT, r16
         
         
000583 d5ad      	rcall	DESHAB_EXTRAM
000584 9508      	ret
         
         ; ------------------------------------------------------------
         ; Recupera el direct. actual y posicion:
         ; ------------------------------------------------------------
          RECUPERA_CONTEXT_EXPLORADOR:
000585 d5a6      	rcall	HAB_EXTRAM
         
000586 9100 4dd2 	lds	r16, CONTEXT_EXPL_DIR+0
000588 9300 0109 	sts	FAT_DIRECT_ACTUAL+0, r16
00058a 9100 4dd3 	lds	r16, CONTEXT_EXPL_DIR+1
00058c 9300 010a 	sts	FAT_DIRECT_ACTUAL+1, r16
00058e 9100 4dd4 	lds	r16, CONTEXT_EXPL_DIR+2
000590 9300 010b 	sts	FAT_DIRECT_ACTUAL+2, r16
000592 9100 4dd5 	lds	r16, CONTEXT_EXPL_DIR+3
000594 9300 010c 	sts	FAT_DIRECT_ACTUAL+3, r16
         	
000596 9100 4dd6 	lds	r16, CONTEXT_EXPL_ENT
000598 9300 0174 	sts	EXPLORER_ENTACT, r16
         	
00059a d596      	rcall	DESHAB_EXTRAM
00059b 9508      	ret
         	
         
         	
         
         		
00059c cfff      fin:	rjmp	fin
         
         
         
         
          .include "fat32.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: fat32.asm
         ;
         ; DESCRIPCION: Funciones de FAT32, directorios, ficheros, etc...
         ;
         ;
         ; RUTINAS:
         ;
         ;
         ; * FAT_INICIAR
         ;
         ; * FAT_CLUSTER2SECTOR
         ;    -> r2..r5: Numero de cluster (r2= LSB)
         ;    <- En RAM: LBA_DIR el sector en LBA correspondiente
         ;
         ; * FAT_SIGUIENTE_CLUSTER
         ;    -> r2..r5: Numero de cluster (r2= LSB) de un fichero/directorio
         ;    <- r2..r5: Numero del siguiente cluster segun la FAT
         ;    <- CARRY=1 si ya no hay mas clusters (fin de fichero)
         ;
         ; * FAT_EXPLORA_DIRECTORIO
         ;     Va explorando las entradas del directorio y realiza una accion segun
         ;      un parametro
         ;
         ;  -> FAT_DIRECT_ACTUAL: Cluster del directorio actual
         ;	.....
         ;
         ;
         ;
         ;-----------------------------------------------------------------------------
         
         
         ;-----------------------------------------------------------------------------
         ;	FAT_FATAL_ERROR
         ;-----------------------------------------------------------------------------
          FAT_FATAL_ERROR:
00059d 94f8      	cli
         
00059e d486      	rcall	LCD_BORRAR	
         	
00059f e1f5      	ldi	ZH, high( STR_FATERR * 2)
0005a0 ebe2      	ldi	ZL,  low( STR_FATERR * 2)
0005a1 d4b7      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
          fat_fatalerror:
0005a2 cfff      	rjmp	fat_fatalerror
         	
         ;-----------------------------------------------------------------------------
         ;
         ;	FAT_INICIAR
         ;
         ;-----------------------------------------------------------------------------
          FAT_INICIAR:
         
         	; Leer sector MBR
         	; ---------------------------
0005a3 2700      	clr	r16
0005a4 9300 0074 	sts	LBA_DIR, r16
0005a6 9300 0075 	sts	LBA_DIR+1, r16
0005a8 9300 0076 	sts	LBA_DIR+2, r16
0005aa 9300 0077 	sts	LBA_DIR+3, r16
         
0005ac e001      	ldi	r16, 1
0005ad 9300 0078 	sts	SECTOR_CNT, r16
         	
0005af e0d4      	ldi	YH, high( SECTOR_BUFFER )
0005b0 e0c0      	ldi	YL,  low( SECTOR_BUFFER )
         	
0005b1 d360      	rcall	ATA_ReadSectors
         	
         	; Comprobar firma $55AA en $0400 + $01FE
0005b2 d579      	rcall	HAB_EXTRAM
         	
0005b3 9100 05fe 	lds	r16, SECTOR_BUFFER + 0x01FE
0005b5 3505      	cpi	r16, 0x55
0005b6 f731      	brne	FAT_FATAL_ERROR
0005b7 9100 05ff 	lds	r16, SECTOR_BUFFER + 0x01FF
0005b9 3a0a      	cpi	r16, 0xAA
0005ba f711      	brne	FAT_FATAL_ERROR
         	
         	; Es un disco formateado OK
         
         	; Buscar el boot sector:
0005bb e0b5      	ldi	XH, high( SECTOR_BUFFER +0x01C6 )
0005bc eca6      	ldi	XL,  low( SECTOR_BUFFER +0x01C6 )
0005bd e0d0      	ldi	YH, high( LBA_DIR )
0005be e7c4      	ldi	YL,  low( LBA_DIR )
0005bf d574      	rcall	COPIAR_X_2_Y_32bits
         		
0005c0 e0d4      	ldi	YH, high( SECTOR_BUFFER )
0005c1 e0c0      	ldi	YL,  low( SECTOR_BUFFER )
         
0005c2 d34f      	rcall	ATA_ReadSectors		; Leer el BOOT SECTOR
         
         	; Cargar datos del boot sector:
         	; ------------------------------------
         ;	rcall	DESHAB_EXTRAM
         ;	ldi	r16, 'H'
         ;	rcall	LCD_TX_DATO
         ;	ldi	r16, 'D'
         ;	rcall	LCD_TX_DATO
         ;	ldi	r16, ':'
         ;	rcall	LCD_TX_DATO
         	
         	
0005c3 d568      	rcall	HAB_EXTRAM
         	
         	; Numero de sectores por cluster
0005c4 9100 040d 	lds	r16, SECTOR_BUFFER+ 13
0005c6 9300 00fc 	sts	BPB_SECSPERCLUS,r16
         	
         	; Cluster del dir. raiz en memoria y como
         	;  directorio actual
0005c8 e0b4      	ldi	XH, high( SECTOR_BUFFER+ 44 )
0005c9 e2ac      	ldi	XL,  low( SECTOR_BUFFER+ 44 )
0005ca e0d0      	ldi	YH, high( BPB_CLUS_DIR_RAIZ )
0005cb efcd      	ldi	YL,  low( BPB_CLUS_DIR_RAIZ )
0005cc d567      	rcall	COPIAR_X_2_Y_32bits
         
0005cd e0b4      	ldi	XH, high( SECTOR_BUFFER+ 44 )
0005ce e2ac      	ldi	XL,  low( SECTOR_BUFFER+ 44 )
0005cf e0d1      	ldi	YH, high( FAT_DIRECT_ACTUAL )
0005d0 e0c9      	ldi	YL,  low( FAT_DIRECT_ACTUAL )
0005d1 d562      	rcall	COPIAR_X_2_Y_32bits
         
         
         	; Primer sector de datos:
         	; -------------------------------
0005d2 9100 0410 	lds	r16,  SECTOR_BUFFER+ 16	; Numero de fats:
         	
         	; Solo soporto que sean 2 !!
0005d4 3002      	cpi	r16, 2
0005d5 f009      	breq	fat_ini_copias_2_ok
0005d6 cfc6      	rjmp	FAT_FATAL_ERROR
          fat_ini_copias_2_ok:
         	
0005d7 9080 0424 	lds	r8,  SECTOR_BUFFER+ 36   ; Numero de sectores / fat
0005d9 9090 0425 	lds	r9,  SECTOR_BUFFER+ 36 +1
0005db 90a0 0426 	lds	r10, SECTOR_BUFFER+ 36 +2
0005dd 90b0 0427 	lds	r11, SECTOR_BUFFER+ 36 +3
         
         	; Multiplicar x numero de fats (2):
0005df 0c88      	lsl	r8	; LSByte
0005e0 1c99      	rol	r9
0005e1 1caa      	rol	r10
0005e2 1cbb      	rol	r11	; MSByte
         	
         
         	; Calc. primer sector de FAT:	
         	; ----------------------------
0005e3 9020 040e 	lds	r2, SECTOR_BUFFER + 14	; + Num. de sectores reservados:
0005e5 9030 040f 	lds	r3, SECTOR_BUFFER + 15
0005e7 2444      	clr	r4
0005e8 2455      	clr	r5
         	
         	; y sumar el offset a partir del BOOT SECTOR:
0005e9 9060 0074 	lds	r6, LBA_DIR	; Suponer tb. q solo es 1 byte... :-(
0005eb 0c26      	add	r2,r6
0005ec 1c30      	adc	r3,r0
0005ed 1c40      	adc	r4,r0
0005ee 1c50      	adc	r5,r0
         
         	; Guardarlo:
0005ef 9220 0105 	sts	FAT_PRIMER_SEC_FAT,   r2	
0005f1 9230 0106 	sts	FAT_PRIMER_SEC_FAT+1, r3
0005f3 9240 0107 	sts	FAT_PRIMER_SEC_FAT+2, r4	
0005f5 9250 0108 	sts	FAT_PRIMER_SEC_FAT+3, r5
         	
         	; Primer sector de datos = primer sector de fat + tam. de FATs	
         ;	clr	r0
0005f7 0c82      	add	r8,r2
0005f8 1c93      	adc	r9,r3
0005f9 1ca4      	adc	r10,r4
0005fa 1cb5      	adc	r11,r5
         
         
         	; Guardar como primer sector de datos:
0005fb 9280 0101 	sts	FAT_PRIMER_SEC_DATOS,   r8
0005fd 9290 0102 	sts	FAT_PRIMER_SEC_DATOS+1, r9
0005ff 92a0 0103 	sts	FAT_PRIMER_SEC_DATOS+2, r10	
000601 92b0 0104 	sts	FAT_PRIMER_SEC_DATOS+3, r11
         	
         		
         	; Mostrar en display nombre del volumen:
         	; ---------------------------------------
         ;	ldi	XH, high( SECTOR_BUFFER+ 71 )
         ;	ldi	XL,  low( SECTOR_BUFFER+ 71 )
         	
         ;fat_ini_label_loop:
         ;	ld	r16, X+
         ;	rcall	DESHAB_EXTRAM
         ;	rcall	LCD_TX_DATO
         ;	rcall	HAB_EXTRAM
         ;	cpi	XL,  low( SECTOR_BUFFER+ 71 +11 )
         ;	brne	fat_ini_label_loop
         
         	
         	
         	; Cache de FAT:
         	; ----------------
000603 2700      	clr	r16
000604 9300 010d 	sts	CACHE_FAT_SECTOR+0, r16
000606 9300 010e 	sts	CACHE_FAT_SECTOR+1, r16
000608 9300 010f 	sts	CACHE_FAT_SECTOR+2, r16
00060a 9300 0110 	sts	CACHE_FAT_SECTOR+3, r16
         
         	
00060c d524      	rcall	DESHAB_EXTRAM
00060d 9508      	ret
         	
         	
         
         
         ;-----------------------------------------------------------------------------
         ;	FAT_CLUSTER2SECTOR
         ;
         ; -> r2..r5: Numero de cluster (r2= LSB)
         ;
         ; <- En RAM: LBA_DIR el sector en LBA correspondiente
         ;-----------------------------------------------------------------------------
          FAT_CLUSTER2SECTOR:
         	; ( Cluster - 2 ) * SecPerClus + FirstDataSec
         	
         	; Cluster - 2
00060e 2400      	clr	r0
00060f e002      	ldi	r16, 0x02
000610 1a20      	sub	r2, r16
000611 0830      	sbc	r3, r0		
000612 0840      	sbc	r4, r0		
000613 0850      	sbc	r5, r0		
         	
         	; * SecPerClus: Es potencia de 2, luego hacer como LSLs:
000614 9060 00fc 	lds	r6, BPB_SECSPERCLUS
          fat_clus2sec_mulloop:
000616 fc60      	sbrc	r6,0	
000617 c006      	rjmp	fat_clus2sec_mulfin
         	
         	; *= 2
000618 0c22      	lsl	r2
000619 1c33      	rol	r3
00061a 1c44      	rol	r4
00061b 1c55      	rol	r5
         	
         	; Siguiente bit:
00061c 9466      	lsr	r6
00061d cff8      	rjmp	fat_clus2sec_mulloop	
          fat_clus2sec_mulfin:
         
         	; Sumar FAT_PRIMER_SEC_DATOS:
00061e 9060 0101 	lds	r6, FAT_PRIMER_SEC_DATOS
000620 9070 0102 	lds	r7, FAT_PRIMER_SEC_DATOS+1
000622 9080 0103 	lds	r8, FAT_PRIMER_SEC_DATOS+2
000624 9090 0104 	lds	r9, FAT_PRIMER_SEC_DATOS+3
         	
000626 0c26      	add	r2, r6
000627 1c37      	adc	r3, r7
000628 1c48      	adc	r4, r8
000629 1c59      	adc	r5, r9
         	
         	; Y guardar resultado en: LBA_DIR
00062a 9220 0074 	sts	LBA_DIR+0, r2
00062c 9230 0075 	sts	LBA_DIR+1, r3
00062e 9240 0076 	sts	LBA_DIR+2, r4
000630 9250 0077 	sts	LBA_DIR+3, r5	
         
000632 9508      	ret
         
         ;-----------------------------------------------------------------------------
         ;	FAT_SIGUIENTE_CLUSTER
         ;
         ; -> r2..r5: Numero de cluster (r2= LSB) de un fichero/directorio
         ;
         ; <- r2..r5: Numero del siguiente cluster segun la FAT
         ;
         ; 	Hay q leer del disco un sector para consultar la FAT
         ;	  y se escribe en el buffer FAT_SEC_BUFFER en RAM.
         ;	Se usa tambien como CACHE de lectura, ya que si es el 
         ; 	 mismo sector que la vez anterior, no se lee del disco :-)
         ;
         ;	Si es el final de fichero, en la fat hay un 
         ;	 0x0FFFFFFF
         ;  	y devuelvo CARRY=1, sino CARRY=0
         ;
         ;-----------------------------------------------------------------------------
          FAT_SIGUIENTE_CLUSTER:
         	; Calcular direccion en bytes de la entrada en la FAT:
         	;  Numero de cluster * 4:
000633 0c22      	lsl	r2
000634 1c33      	rol	r3
000635 1c44      	rol	r4
000636 1c55      	rol	r5
         	
000637 0c22      	lsl	r2
000638 1c33      	rol	r3
000639 1c44      	rol	r4
00063a 1c55      	rol	r5
         	
         	; Guardar para luego: Offset sobre el sector
00063b 922f      	push	r2
00063c 923f      	push	r3
         
         	; % 512 para saber numero de sector con respecto
         	;  al comienzo de la FAT: 
         	; Guardar en r6..r8
00063d 2c63      	mov	r6, r3
00063e 2c74      	mov	r7, r4
00063f 2c85      	mov	r8, r5
000640 9486      	lsr	r8
000641 9477      	ror	r7
000642 9467      	ror	r6	; r6 = LSByte
         	
         	; Sumar al primer sector de la fat para leer 
         	;  el sector que tiene la entrada del cluster 
         	;  que buscamos:
         	
000643 9100 0105 	lds	r16, FAT_PRIMER_SEC_FAT	+ 0
000645 9110 0106 	lds	r17, FAT_PRIMER_SEC_FAT	+ 1
000647 9120 0107 	lds	r18, FAT_PRIMER_SEC_FAT	+ 2
000649 9130 0108 	lds	r19, FAT_PRIMER_SEC_FAT	+ 3
         	
00064b 2400      	clr	r0
00064c 0d06      	add	r16, r6
00064d 1d17      	adc	r17, r7
00064e 1d28      	adc	r18, r8
00064f 1d30      	adc	r19, r0
         
         	; Leer ese sector:
000650 9300 0074 	sts	LBA_DIR+0, r16	
000652 9310 0075 	sts	LBA_DIR+1, r17
000654 9320 0076 	sts	LBA_DIR+2, r18	
000656 9330 0077 	sts	LBA_DIR+3, r19
         	
         	
         	; CACHE: Comprobar si ya esta leido!!
         	; ------
000658 9010 010d 	lds	r1, CACHE_FAT_SECTOR+0
00065a 1610      	cp	r1, r16
00065b f469      	brne	fatsigclus_no_en_cache
00065c 9010 010e 	lds	r1, CACHE_FAT_SECTOR+1
00065e 1611      	cp	r1, r17
00065f f449      	brne	fatsigclus_no_en_cache
000660 9010 010f 	lds	r1, CACHE_FAT_SECTOR+2
000662 1612      	cp	r1, r18
000663 f429      	brne	fatsigclus_no_en_cache
000664 9010 0110 	lds	r1, CACHE_FAT_SECTOR+3
000666 1613      	cp	r1, r19
000667 f409      	brne	fatsigclus_no_en_cache
         	
         	; Si esta en cache:
         	; ----------------------
000668 c00e      	rjmp	fatsigclus_si_en_cache
         	
         	
          fatsigclus_no_en_cache:
         	; Pues guardar la direccion de este sector para saber que 
         	;  ya esta cargado por si la proxima se repite:
000669 9300 010d 	sts	CACHE_FAT_SECTOR+0, r16
00066b 9310 010e 	sts	CACHE_FAT_SECTOR+1, r17
00066d 9320 010f 	sts	CACHE_FAT_SECTOR+2, r18
00066f 9330 0110 	sts	CACHE_FAT_SECTOR+3, r19	
         
000671 e001      	ldi	r16, 1
000672 9300 0078 	sts	SECTOR_CNT, r16
         	
000674 e0d6      	ldi	YH, high( FAT_SEC_BUFFER )
000675 e0c0      	ldi	YL, low ( FAT_SEC_BUFFER )
         	
000676 d29b      	rcall	ATA_ReadSectors
         	
          fatsigclus_si_en_cache:
         
         	; Offset del sector: r2 + bit 0 de r3:
000677 903f      	pop	r3
000678 902f      	pop	r2
         
000679 e001      	ldi	r16, 0x01
00067a 2230      	and	r3, r16
         	
00067b e0d6      	ldi	YH, high( FAT_SEC_BUFFER )
00067c e0c0      	ldi	YL, low ( FAT_SEC_BUFFER )
         	
00067d 0dc2      	add	YL, r2
00067e 1dd3      	adc	YH, r3
         	
         	; Y apunta a siguiente cluster en LSB primero:
00067f d4ac      	rcall	HAB_EXTRAM
         	
000680 9029      	ld	r2, Y+
000681 9039      	ld	r3, Y+
000682 9049      	ld	r4, Y+
000683 9059      	ld	r5, Y+
         	
         	; En realidad son 28 bits: Sobran 4:
000684 2d05      	mov	r16, r5
000685 700f      	andi	r16, 0x0F
000686 2e50      	mov	r5, r16
         	
         
         	; Fin de fichero?
000687 e00f      	ldi	r16, 0x0F
000688 1650      	cp	r5, r16
000689 f449      	brne	fatsigclus_fin
00068a ef0f      	ldi	r16, 0xFF
00068b 1640      	cp	r4, r16
00068c f431      	brne	fatsigclus_fin
00068d 1630      	cp	r3, r16
00068e f421      	brne	fatsigclus_fin
00068f 1620      	cp	r2, r16
000690 f411      	brne	fatsigclus_fin
         	
000691 9408      	sec	
000692 9508      	ret
         	
          fatsigclus_fin:
000693 9488      	clc
000694 9508      	ret
         	
         
         
         ; ******************************************
         ; ******************************************
          FAT_DEBUG_DUMP_Y:
000695 d49b      	rcall	DESHAB_EXTRAM
         	
          dump_loop2:
000696 d38e      	rcall	LCD_BORRAR	
         	
000697 e07a      	ldi	r23, 10
          dump_loop:
000698 d493      	rcall	HAB_EXTRAM
000699 9109      	ld	r16, Y+
         
00069a d496      	rcall	DESHAB_EXTRAM
00069b d3ce      	rcall	LCD_ESCRIBE_R16_HEX
         ;	rcall	LCD_TX_DATO
         	
00069c 957a      	dec	r23
00069d f7d1      	brne	dump_loop
         	
00069e e400      	ldi	r16, 0x40
00069f d3c5      	rcall	LCD_SET_CURSOR_POS_R16
0006a0 e07a      	ldi	r23, 10
          dump_loop3:
0006a1 d48a      	rcall	HAB_EXTRAM
0006a2 9109      	ld	r16, Y+
         
0006a3 d48d      	rcall	DESHAB_EXTRAM
0006a4 d3c5      	rcall	LCD_ESCRIBE_R16_HEX
         ;	rcall	LCD_TX_DATO
         		
0006a5 957a      	dec	r23
0006a6 f7d1      	brne	dump_loop3
         	
         
0006a7 eb94      	ldi	r25, 180
0006a8 d160      	rcall	RETARDO_R25x25ms
         	
0006a9 cfec      	rjmp	dump_loop2
         
         
         
         
         ;-----------------------------------------------------------------------------
         ;	FAT_EXPLORA_DIRECTORIO
         ;
         ; Va explorando las entradas del directorio y realiza una accion segun
         ;  un parametro
         ;
         ;  -> FAT_DIRECT_ACTUAL: Cluster del directorio actual
         ;
         ;  -> FAT_PETICION: Indica que hacer:
         ;	0x00: Contar: devuelve en FAT_DIRENT_ENCONTRADAS el numero de ficheros y directorios
         ;	0x01: Leer entrada de directorio decodificada y guardarla en 
         ;		su registro en ram ( Campos FATDE_XXXX )
         ;
         ;  -> FAT_PETICION_NUM_ENTR: Numero de entrada a leer.	
         ; 
         ;
         ;-----------------------------------------------------------------------------
          FAT_EXPLORA_DIRECTORIO:
0006aa 93bf      	push	XH
0006ab 93af      	push	XL
0006ac 93df      	push	YH
0006ad 93cf      	push	YL
         
         	; r13 = numero de sector del "directorio" en el que estamos:
0006ae ef0f      	ldi	r16, 0xFF
0006af 2ed0      	mov	r13, r16	; Nada mas empezar se incrementa y 
         				;  pasa a cero
         				
         	; Iniciar cluster actual: FATEXPLORER_CLUSACT
0006b0 e0b1      	ldi	XH, high( FAT_DIRECT_ACTUAL )
0006b1 e0a9      	ldi	XL, low ( FAT_DIRECT_ACTUAL )
0006b2 e0d1      	ldi	YH, high( FATEXPLORER_CLUSACT )
0006b3 e1c4      	ldi	YL, low ( FATEXPLORER_CLUSACT )
0006b4 d47f      	rcall	COPIAR_X_2_Y_32bits
         	
         	
         	
         	; r14 = 1 si estoy analizando una entrada larga.
0006b5 24ee      	clr	r14
         	
         	; FAT_DIRENT_ENCONTRADAS a cero:
0006b6 2700      	clr	r16
0006b7 9300 0113 	sts	FAT_DIRENT_ENCONTRADAS, r16
         	
         	; (Z) apunta en SECTOR_BUFFER a la entrada analizada en cada momento
0006b9 e0f6      	ldi	ZH, high ( SECTOR_BUFFER +512 )
0006ba e0e0      	ldi	ZL, low ( SECTOR_BUFFER + 512 ) ; +512 para q nada mas empezar
         						;  cargue el primer sector:
         	
         
         
         	; -------------------------------
         	; 	      BUCLE
         	; -------------------------------
          fat_explor_dir_loop:
         	; Siguiente sector ?
0006bb 30f6      	cpi	ZH, high( SECTOR_BUFFER +512 )	
0006bc f409      	brne	ve_fat_explor_dir_no_sector
         
0006bd 1000      	cpse	r0,r0
          ve_fat_explor_dir_no_sector:	
0006be c03f      	rjmp	fat_explor_dir_no_sector
         	
         
         	; Si, necesitamos incrementar el contador de sector 
         	;  actual en el directorio:
0006bf 94d3      	inc	r13
         	
         	; Siguiente cluster??
0006c0 9100 00fc 	lds	r16, BPB_SECSPERCLUS
0006c2 150d      	cp	r16, r13
0006c3 f4a1      	brne	fat_explor_dir_no_cluster
         	
         	; Si, hay que pasar al siguiente cluster:
0006c4 9020 0114 	lds	r2, FATEXPLORER_CLUSACT+0
0006c6 9030 0115 	lds	r3, FATEXPLORER_CLUSACT+1
0006c8 9040 0116 	lds	r4, FATEXPLORER_CLUSACT+2
0006ca 9050 0117 	lds	r5, FATEXPLORER_CLUSACT+3
         
         
         
0006cc df66      	rcall	FAT_SIGUIENTE_CLUSTER
0006cd f408      	brcc	fat_explor_no_fin_direct
0006ce c036      	rjmp	fat_explor_dir_ve_fin		; Final de directorio !!	
          fat_explor_no_fin_direct:
         	
         
         	; Guardar nuevo cluster actual
0006cf 9220 0114 	sts	FATEXPLORER_CLUSACT+0,r2
0006d1 9230 0115 	sts	FATEXPLORER_CLUSACT+1,r3
0006d3 9240 0116 	sts	FATEXPLORER_CLUSACT+2,r4
0006d5 9250 0117 	sts	FATEXPLORER_CLUSACT+3,r5
         		
0006d7 24dd      	clr	r13	; y ver primer sector en el nuevo cluster
         
          fat_explor_dir_no_cluster:
         
         	; Cargar el sector numero "r13" del cluster 
         	;  "FATEXPLORER_CLUSACT"
         	
         	; Pasar de cluster a sector y sumarle r13:
0006d8 9020 0114 	lds	r2, FATEXPLORER_CLUSACT+0
0006da 9030 0115 	lds	r3, FATEXPLORER_CLUSACT+1
0006dc 9040 0116 	lds	r4, FATEXPLORER_CLUSACT+2
0006de 9050 0117 	lds	r5, FATEXPLORER_CLUSACT+3
         	
0006e0 df2d      	rcall	FAT_CLUSTER2SECTOR
         
0006e1 9020 0074 	lds	r2, LBA_DIR+0
0006e3 9030 0075 	lds	r3, LBA_DIR+1
0006e5 9040 0076 	lds	r4, LBA_DIR+2
0006e7 9050 0077 	lds	r5, LBA_DIR+3
         
0006e9 2400      	clr	r0
0006ea 0c2d      	add	r2, r13
0006eb 1c30      	adc	r3, r0
0006ec 1c40      	adc	r4, r0
0006ed 1c50      	adc	r5, r0
         
0006ee 9220 0074 	sts	LBA_DIR+0,r2
0006f0 9230 0075 	sts	LBA_DIR+1,r3
0006f2 9240 0076 	sts	LBA_DIR+2,r4
0006f4 9250 0077 	sts	LBA_DIR+3,r5
         	
         	; Y cargar ese sector:
0006f6 e0d4      	ldi	YH, high ( SECTOR_BUFFER  )
0006f7 e0c0      	ldi	YL, low  ( SECTOR_BUFFER  ) 
         
0006f8 e001      	ldi	r16,0x01
0006f9 9300 0078 	sts	SECTOR_CNT, r16
         		
0006fb d216      	rcall	ATA_ReadSectors
         
         
         	; Iniciar puntero a comienzo del nuevo sector:
0006fc e0f4      	ldi	ZH, high ( SECTOR_BUFFER  )
0006fd e0e0      	ldi	ZL, low  ( SECTOR_BUFFER  ) 	
         
          fat_explor_dir_no_sector:
0006fe d42d      	rcall	HAB_EXTRAM
         
         	; Final de entradas?? 
         	; Si DIR_Name[0]= 0x00
         	; Si DIR_Name[0]= 0xE5 es borrada: IGNORAR
0006ff 8170      	ld	r23, Z
         	
000700 3070      	cpi	r23, 0x00
000701 f019      	breq	fat_explor_dir_ve_fin
000702 3e75      	cpi	r23, 0xE5
000703 f051      	breq	fat_explo_ignorar_ent
         	
         
000704 1000      	cpse	r0,r0	; Saltarse el RJMP	
          fat_explor_dir_ve_fin:
         	; Fin de entradas:
000705 c09f      	rjmp	fat_explor_dir_fin
         
         	; Ver ATTRIB de DirectoryEntry:
000706 8503      	ldd	r16, Z+11
         	
         	; Entrada larga??
000707 300f      	cpi	r16, 0x0F	
000708 f031      	breq	fat_explor_entrada_larga
         	
         	; Si es un "volume" ignorar:
000709 fd03      	sbrc	r16, 3	; 0x08 = VOLUME_ID
00070a c098      	rjmp	fat_explor_dir_sig
         	
         	; Sera una entrada corta:
00070b fd04      	sbrc	r16, 4	; 0x10
00070c c029      	rjmp	fat_explor_entrada_corta	; Es un directorio
         	
         	; El resto de valores, deben de ser entradas cortas de ficheros:
         ;	sbrc	r16, 5	; 0x20
00070d c028      	rjmp	fat_explor_entrada_corta	; Es un fichero
         
         	
          fat_explo_ignorar_ent:	
00070e c094      	rjmp	fat_explor_dir_sig
         
         
         	;  ENTRADA LARGA
         	; ------------------------------------
          fat_explor_entrada_larga:
         	; Es la primera?
00070f 20ee      	tst	r14
000710 f419      	brne	fat_explor_entrada_larga_prim
         
         	; Si es la primera
         	
         	; Iniciar puntero para formar nombres largos:
000711 2700      	clr	r16
000712 92e0 0172 	sts	FATDE_FILENAME_CONTA, r14
         		
         
         	; No es la primera
          fat_explor_entrada_larga_prim:
         
         	; Indicar entrada larga:
000714 e001      	ldi	r16, 0x01
000715 2ee0      	mov	r14, r16
         
         	; Si solo estamos contando las entradas, no formar
         	;  los nombres:
000716 9100 0111 	lds	r16, FAT_PETICION
000718 3000      	cpi	r16, 0x00	; No contar: Formar nombre
000719 f409      	brne	fat_explor_entlar_formar	
         	
         	; Solo contar: No hacer trabajo innecesario
00071a c088      	rjmp	fat_explor_dir_sig	
         
          fat_explor_entlar_formar:
         
         	; Ir formando nombre de fichero en buffer
         	;  FATDE_FILENAME 
         	;  Contador de bytes: 
         	;  FATDE_FILENAME_CONTA	
         	;
         	; Cada entrada tiene hasta 13 caracteres en posiciones:
         	; Z + ....  1 3 5 7 9 14 16 18 20 22 24 28 30
         	; 
         	; Hay que cargarlos al reves por si acaban con un 0x00 
         	;   o un 0xFF e ignorar esos bytes. Al final se invertira
         	;   el buffer.
00071b 8d06      	ldd	r16, Z + 30
00071c d08e      	rcall	fat_formar_nombre
00071d 8d04      	ldd	r16, Z + 28
00071e d08c      	rcall	fat_formar_nombre
00071f 8d00      	ldd	r16, Z + 24
000720 d08a      	rcall	fat_formar_nombre
000721 8906      	ldd	r16, Z + 22
000722 d088      	rcall	fat_formar_nombre
000723 8904      	ldd	r16, Z + 20
000724 d086      	rcall	fat_formar_nombre
000725 8902      	ldd	r16, Z + 18
000726 d084      	rcall	fat_formar_nombre
000727 8900      	ldd	r16, Z + 16
000728 d082      	rcall	fat_formar_nombre
000729 8506      	ldd	r16, Z + 14
00072a d080      	rcall	fat_formar_nombre
00072b 8501      	ldd	r16, Z + 9
00072c d07e      	rcall	fat_formar_nombre
00072d 8107      	ldd	r16, Z + 7
00072e d07c      	rcall	fat_formar_nombre
00072f 8105      	ldd	r16, Z + 5
000730 d07a      	rcall	fat_formar_nombre
000731 8103      	ldd	r16, Z + 3
000732 d078      	rcall	fat_formar_nombre
000733 8101      	ldd	r16, Z + 1
000734 d076      	rcall	fat_formar_nombre
         	
         		
000735 c06d      	rjmp	fat_explor_dir_sig
         
         
         	;  ENTRADA CORTA
         	; ------------------------------------
          fat_explor_entrada_corta:
         	; Forma parte de una entrada larga encadenada??
000736 20ee      	tst	r14
000737 f101      	breq	fat_explor_entcorta
         	
         	; Es la ultima de una entrada larga: Poner cero de fin de cadena:
000738 e0b1      	ldi	XH, high ( FATDE_FILENAME )
000739 e2a1      	ldi	XL,  low ( FATDE_FILENAME )
         	
00073a 9110 0172 	lds	r17, FATDE_FILENAME_CONTA
         	
         	; Posicionar 
00073c 2400      	clr	r0
00073d 0fa1      	add	XL, r17
00073e 1db0      	adc	XH, r0
         	
         	; Acabar cadena
00073f 920d      	st	X+, r0
         	
         	; Dar la vuelta al nombre de fichero que se habra guardado 
         	;  en el buffer en orden inverso:
000740 e0b1      	ldi	XH, high ( FATDE_FILENAME )
000741 e2a1      	ldi	XL,  low ( FATDE_FILENAME )
000742 2fdb      	mov	YH, XH
000743 2fca      	mov	YL, XL
         
000744 9110 0172 	lds	r17, FATDE_FILENAME_CONTA
000746 951a      	dec	r17	; Direccionar el ultimo caracter ESCRITO
         	
000747 2400      	clr	r0
000748 0fa1      	add	XL, r17
000749 1db0      	adc	XH, r0
         
         	; X apunta al FINAL
         	; Y apunta al INICIO
         	; Recorrer NUM_CARACTERES / 2
00074a 9120 0172 	lds	r18, FATDE_FILENAME_CONTA
00074c 9526      	lsr	r18
         
00074d 2400      	clr	r0
00074e e031      	ldi	r19, 0x01
          fat_explor_reordenar_filename:
00074f 8108      	ld	r16, Y
000750 911c      	ld	r17, X
         	
000751 9319      	st	Y+, r17
000752 930c      	st	X, r16
         		
000753 1ba3      	sub	XL, r19
000754 09b0      	sbc	XH, r0
         	
         	
000755 952a      	dec	r18
000756 f7c1      	brne	fat_explor_reordenar_filename
         	
000757 c01d      	rjmp	fat_explor_entcorta_sig
         		
         
          fat_explor_entcorta:
         	; Es corta sin mas: 
         	
         	; Copiar nombre de fichero: 8 caracteres:
000758 2fbf      	mov	XH, ZH
000759 2fae      	mov	XL, ZL
         	
00075a e0d1      	ldi	YH, high( FATDE_FILENAME )
00075b e2c1      	ldi	YL,  low( FATDE_FILENAME )
         	
00075c e028      	ldi	r18, 8
00075d d3d7      	rcall	COPIAR_X_2_Y_R18_BYTES
         	
         	; Hay extension??
00075e 8500      	ldd	r16, Z+8
00075f 3200      	cpi	r16, ' '
000760 f439      	brne	fat_explor_si_extension
000761 8501      	ldd	r16, Z+9
000762 3200      	cpi	r16, ' '
000763 f421      	brne	fat_explor_si_extension
000764 8502      	ldd	r16, Z+10
000765 3200      	cpi	r16, ' '
000766 f409      	brne	fat_explor_si_extension
         	
         	; Si no hay extension, no poner ni el punto!
000767 c004      	rjmp	fat_explor_fin_extension	
         
          fat_explor_si_extension:
000768 e20e      	ldi	r16, '.'
000769 9309      	st	Y+, r16
         
         	; Y copiar extension: 3 caracteres
00076a e023      	ldi	r18, 3
00076b d3c9      	rcall	COPIAR_X_2_Y_R18_BYTES
         	
         	; Quitar espacios en blanco al final, si los hay:
          fat_explor_fin_extension:
00076c 910a      	ld	r16, -Y
         
          fat_explor_nombre_trim:
00076d 8108      	ld	r16, Y
00076e 3200      	cpi	r16, ' '
00076f f411      	brne	fat_explor_fin_trim
         	
         	; Quitar ese espacio y seguir:
000770 910a      	ld	r16, -Y
000771 cffb      	rjmp	fat_explor_nombre_trim
         	
         	
          fat_explor_fin_trim:
         	; Terminar cadena con un 0x00:
000772 2700      	clr	r16
000773 9621      	adiw	YL, 1
000774 9309      	st	Y+, r16
         		
         	
          fat_explor_entcorta_sig:	
         	; Quitar flag de estoy en entrada larga:
000775 24ee      	clr	r14
         	
         	; Resetear contador de direccion de texto largo:
000776 92e0 0172 	sts	FATDE_FILENAME_CONTA, r14
         	
         	
         	; Incrementar contador de entradas encontradas:
000778 9100 0113 	lds	r16, FAT_DIRENT_ENCONTRADAS
00077a 9503      	inc	r16
00077b 9300 0113 	sts	FAT_DIRENT_ENCONTRADAS, r16
         	
         	; Si solo contando entradas no coger mas datos:
00077d 9100 0111 	lds	r16, FAT_PETICION
00077f 3000      	cpi	r16, 0x00
000780 f111      	breq	fat_explor_dir_sig	; Solo contar
         	
         	
         	; Se supone que es un comando de recuperar entrada:
         	; ----------------------------------------------------
         			
         	; Si el numero de entrada pedida es la actual, 
         	;  copiar el resto de datos al FAT_DE y salir
000781 9100 0112 	lds	r16, FAT_PETICION_NUM_ENTR
000783 9110 0113 	lds	r17, FAT_DIRENT_ENCONTRADAS
000785 1701      	cp	r16, r17
000786 f4e1      	brne	fat_explor_dir_sig
         	
         	; Si, es la que buscamos:
         	; --------------------------------
         	 
         	; Atributo:
000787 8503      	ldd	r16, Z+11
000788 9300 0118 	sts	FATDE_ATTR, r16
         	
         	; Clusters:
00078a 8d02      	ldd	r16, Z+26
00078b 9300 0119 	sts	FATDE_CLUSTER+0, r16
00078d 8d03      	ldd	r16, Z+27
00078e 9300 011a 	sts	FATDE_CLUSTER+1, r16
000790 8904      	ldd	r16, Z+20
000791 9300 011b 	sts	FATDE_CLUSTER+2, r16
000793 8905      	ldd	r16, Z+21
000794 9300 011c 	sts	FATDE_CLUSTER+3, r16
         
         	; Tamaño fichero:
000796 8d04      	ldd	r16, Z+28
000797 9300 011d 	sts	FATDE_FILESIZE+0,r16
000799 8d05      	ldd	r16, Z+29
00079a 9300 011e 	sts	FATDE_FILESIZE+1,r16
00079c 8d06      	ldd	r16, Z+30
00079d 9300 011f 	sts	FATDE_FILESIZE+2,r16
00079f 8d07      	ldd	r16, Z+31
0007a0 9300 0120 	sts	FATDE_FILESIZE+3,r16
         	
         	; Ya esta, salir:
0007a2 c002      	rjmp	fat_explor_dir_fin
         		
         
         
         	
          fat_explor_dir_sig:
         
         	; Siguiente entrada de directorio:
0007a3 96b0      	adiw	ZL, 32
0007a4 cf16      	rjmp	fat_explor_dir_loop
         	
          fat_explor_dir_fin:
         
0007a5 d38b      	rcall	DESHAB_EXTRAM
         
0007a6 91cf      	pop	YL
0007a7 91df      	pop	YH
0007a8 91af      	pop	XL
0007a9 91bf      	pop	XH
         	
0007aa 9508      	ret
         	
         
         ; --------------------------------------------------------
         ; fat_formar_nombre
         ;
         ;   Va formando el nombre largo con los bytes en trozos
         ;    Byte entra en r16, si ve que vale, lo guarda en 
         ;     FATDE_FILENAME, segun el indice FATDE_FILENAME_CONTA
         ; --------------------------------------------------------
          fat_formar_nombre:
0007ab 93ff      	push 	ZH
0007ac 93ef      	push	ZL
         	
0007ad 3000      	cpi	r16, 0x00
0007ae f0d9      	breq	fat_formar_nombre_fin
0007af 3f0f      	cpi	r16, 0xFF
0007b0 f0c9      	breq	fat_formar_nombre_fin
         	
         	; Caracter valido:
0007b1 e0b1      	ldi	XH, high ( FATDE_FILENAME )
0007b2 e2a1      	ldi	XL,  low ( FATDE_FILENAME )
         	
0007b3 9110 0172 	lds	r17, FATDE_FILENAME_CONTA
         	
         	; Si estamos en el maximo del buffer, no guardar caracter:
0007b5 3510      	cpi	r17, FAT_MAX_FILENAME
0007b6 f099      	breq	fat_formar_nombre_fin
         	
0007b7 2400      	clr	r0
0007b8 0fa1      	add	XL, r17
0007b9 1db0      	adc	XH, r0
         	
         	; Transformaciones de caracteres: Si 
0007ba e0ff      	ldi	ZH, high ( FAT_TRANSF_CHARS*2 )
0007bb e9ea      	ldi	ZL,  low ( FAT_TRANSF_CHARS*2 )
         	
          fat_frm_nom_lp:
         	; En r1 esta el origen, en r0 por lo que se debe cambiar:
0007bc 95c8      	lpm
0007bd 2c10      	mov	r1, r0
0007be 9631      	adiw	ZL, 1
0007bf 95c8      	lpm
0007c0 9631      	adiw	ZL, 1
         	
0007c1 2011      	tst	r1
0007c2 f019      	breq	fat_frmnom_ok
         	
         	; Es r1?
0007c3 1610      	cp	r1, r16
0007c4 f7b9      	brne	fat_frm_nom_lp
         	
         	; Si, cambiar:
0007c5 2d00      	mov	r16, r0
         		
          fat_frmnom_ok:
0007c6 930d      	st	X+, r16
         	
0007c7 9513      	inc	r17
0007c8 9310 0172 	sts	FATDE_FILENAME_CONTA, r17
         
          fat_formar_nombre_fin:
         
0007ca 91ef      	pop	ZL
0007cb 91ff      	pop	ZH
         	
0007cc 9508      	ret
         	
         
         ; Tabla para transformar caracteres que no se verían bien
         ;  en el display:
          FAT_TRANSF_CHARS:
          	.db	0xE1,'a'
0007cd 61e1
          	.db	0xE9,'e'
0007ce 65e9
          	.db	0xED,'i'
0007cf 69ed
          	.db	0xF3,'o'
0007d0 6ff3
          	.db	0xFA,'u'
0007d1 75fa
          	.db	0xC1,'A'
0007d2 41c1
          	.db	0xC9,'E'
0007d3 45c9
          	.db	0xCD,'I'
0007d4 49cd
          	.db	0xD3,'O'
0007d5 4fd3
          	.db	0xDA,'U'
0007d6 55da
          	.db	0xA1,'!'
0007d7 21a1
          	.db	0xBF,'?'
0007d8 3fbf
          	.db	0xF1,0xEE	; Eñe mayusc y minus.
0007d9 eef1
          	.db	0xD1,0xEE	; Eñe mayusc y minus.
0007da eed1
         	
          	.db	0,0
0007db 0000
         	
         ; --------------------------------------------------------
         ;  CARACTER_MINUSCULA
         ;  
         ;  Transforma en caracter en r16 a minuscula
         ; --------------------------------------------------------
          CARACTER_MINUSCULA:
0007dc 931f      	push	r17
         	
0007dd 3401      	cpi	r16, 'A'
0007de f020      	brlo	car_minus_fin
0007df 350b      	cpi	r16, 'Z'+1
0007e0 f410      	brsh	car_minus_fin
         	
         	; Es mayuscula:
0007e1 e210      	ldi	r17, 'a'-'A'
0007e2 0f01      	add	r16, r17
         	
          car_minus_fin:
         
0007e3 911f      	pop	r17
0007e4 9508      	ret
         	
         
         	
         ; --------------------------------------------------------
         ;   TEST_FILENAME_ES_MP3
         ;
         ; Devuelve CARRY = 1/0 si el nombre de fichero en 
         ;   FATDE_FILENAME acaba/o no en ".mp3"
         ;	
         ; --------------------------------------------------------
          TEST_FILENAME_ES_MP3:
0007e5 93bf      	push	XH
0007e6 93af      	push	XL
         	
0007e7 e0b1      	ldi	XH, high (FATDE_FILENAME)
0007e8 e2a1      	ldi	XL,  low (FATDE_FILENAME)
0007e9 d350      	rcall	STRLEN
         
         	; X apunta a despues del 0x00
0007ea 9711      	sbiw 	XL, 1
         	; Ahora apunta al cero del final:
         	
0007eb 910e      	ld	r16, -X
0007ec dfef      	rcall	CARACTER_MINUSCULA
0007ed 3303      	cpi	r16, '3'
0007ee f461      	brne	tst_file_mp3_no
         
0007ef 910e      	ld	r16, -X
0007f0 dfeb      	rcall	CARACTER_MINUSCULA
0007f1 3700      	cpi	r16, 'p'
0007f2 f441      	brne	tst_file_mp3_no
         
0007f3 910e      	ld	r16, -X
0007f4 dfe7      	rcall	CARACTER_MINUSCULA
0007f5 360d      	cpi	r16, 'm'
0007f6 f421      	brne	tst_file_mp3_no
         	
         	; Si es MP3:
         	
0007f7 91af      	pop	XL
0007f8 91bf      	pop	XH
         	
0007f9 9408      	sec
0007fa 9508      	ret	
         
          tst_file_mp3_no:
0007fb 91af      	pop	XL
0007fc 91bf      	pop	XH
         
0007fd 9488      	clc
0007fe 9508      	ret          .include "retardos.asm"
         ;----------------------------------------------------
         ; FICHERO: Retardos.asm
         ;
         ; DESCRIPCION: Implementa distintas funciones para
         ;		 generar retardos de distinta longitud
         ;
         ; Jose Luis Blanco Claraco @ 2001-2002
         ;----------------------------------------------------
         
         
         
         ;----------------------------------------------------
         ;  RETARDO_R25_MAX100us  (r25: 1,2,...,255,0)
         ;
         ;----------------------------------------------------
          RETARDO_R25_MAX100us:
0007ff 959a      	dec	r25
000800 f7f1      	brne	RETARDO_R25_MAX100us
000801 9508      	ret
         
         ;----------------------------------------------------
         ;  RETARDO_R25_MAX25ms   (r25: 1,2,...,255,0)
         ;
         ;----------------------------------------------------
          RETARDO_R25_MAX25ms:
000802 939f      	push	r25
000803 e090      	ldi	r25,0
000804 dffa      	rcall	RETARDO_R25_MAX100us
000805 919f      	pop	r25
         	
000806 959a      	dec	r25
000807 f7d1      	brne	RETARDO_R25_MAX25ms
000808 9508      	ret
         
         ;----------------------------------------------------
         ;  RETARDO_R25x25ms
         ;
         ;    Retarda r25 veces 25 ms
         ;----------------------------------------------------
          RETARDO_R25x25ms:
000809 939f      	push	r25
         
          ret_25x_bucl:	
00080a 939f      	push	r25
00080b e090      	ldi	r25,0
00080c dff5      	rcall	RETARDO_R25_MAX25ms
00080d 919f      	pop	r25
00080e 959a      	dec	r25
00080f f7d1      	brne	ret_25x_bucl	
         	
000810 919f      	pop	r25
000811 9508      	ret          .include "conversiones.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: Conversiones.asm
         ;
         ; DESCRIPCION: Implementa rutinas de conversiones varias y utilidades.
         ;
         ; RUTINAS:
         ; --------
         ;
         ;  - BYTE2ASCII_R18: Coge un numero de 8 bits con signo 
         ;      de r18 y lo guarda en DECIMAL en memoria, en X.
         ;
         ;  - R16_2_X_HEX: Escribe dos digitos en hexadecimal en r16 en X
         ;
         ;  - HEX_X_2_BIN: Pasa 2 bytes ascii en hexadecimal de X, y devuelve 
         ;	el valor en r16
         ;
         ;  - HEX2BIN:	Pasa un caracter ascii en r16, y lo devuelve como valor
         ;      numerico en el nibble bajo en r16
         ; 	Al salir: C=0 si todo bien, C=1 si no es digito hex.
         ;
         ;  - CERO_2_X: Guarda un byte a 0 en X e incrementa este.
         ;
         ;  - TABLA_SEGUN_R16_A_Z:  Pone en Z direccion segun la tabla en (Z) y temp
         ;
         ;-----------------------------------------------------------------------------
         
         
         ;--------------------------------------------------------
         ;  - BYTE2ASCII_R18: Coge un numero de 8 bits sin signo 
         ;      de r18 y lo guarda en ascii en memoria, en X.
         ;
         ;  MOD: Siempre imprime las decenas
         ;-----------------------------------------------------------------------------
          BYTE2ASCII_R18:
         	; Centenas ----------------------
000812 2711      	clr	r17
          byte2ascii_cents_loop:
000813 2f02      	mov	temp,r18
000814 5604      	subi	temp,100
000815 f01a      	brmi	byte2ascii_cents_fin	; Es negativo?
000816 9513      	inc	r17
000817 2f20      	mov	r18,temp		; Se va descontando de r18
000818 cffa      	rjmp	byte2ascii_cents_loop
         
          byte2ascii_cents_fin: 
         	; En r17: No imprimirlo si es cero:
000819 2311      	tst	r17
00081a f009      	breq	byte2ascii_cents_0
00081b d035      	rcall	LCD_R17_BIN2BCD
          byte2ascii_cents_0:
         	
         	; Decenas ----------------------
00081c 2711      	clr	r17
          byte2ascii_decs_loop:
00081d 2f02      	mov	temp,r18
00081e 500a      	subi	temp,10
00081f f01a      	brmi	byte2ascii_decs_fin	; Es negativo?
000820 9513      	inc	r17
000821 2f20      	mov	r18,temp		; Se va descontando de r18
000822 cffa      	rjmp	byte2ascii_decs_loop
         
          byte2ascii_decs_fin: 
         	; En r17:
         	; En r17: No imprimirlo si es cero:
         ;	tst	r17
         ;	breq	byte2ascii_decs_0
000823 d02d      	rcall	LCD_R17_BIN2BCD
          byte2ascii_decs_0:
         	
         	; Unidades ----------------------
000824 2f12      	mov	r17,r18			; Ya solo quedan unidades
000825 d02b      	rcall	LCD_R17_BIN2BCD
         
         
         
000826 9508      	ret
         
         
         ;----------------------------------------------------
         ;           R16_2_X_HEX
         ;
         ;  Escribe dos digitos en hexadecimal en r16 en X
         ;----------------------------------------------------
          R16_2_X_HEX:
000827 930f      	push	r16
000828 2f10      	mov	r17,r16	; Guardar byte a mostrar en r16
         
         	; Nibble superior:	
000829 9512      	swap	r17
00082a d24d      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII
00082b 930d      	st	X+,r16
         	
         	; Nibble inferior:
00082c 910f      	pop	r16
00082d 930f      	push	r16
00082e 2f10      	mov	r17,r16	; Guardar byte a mostrar en r16
         
00082f d248      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII
000830 930d      	st	X+,r16
         
000831 910f      	pop	r16
000832 9508      	ret
         
         
         
         ;----------------------------------------------------
         ;  - HEX_X_2_BIN: Pasa 2 bytes ascii en hexadecimal 
         ;          de X, y devuelve el valor en r16
         ;----------------------------------------------------
          HEX_X_2_BIN:
         	; Nibble alto:
000833 910d      	ld	r16,X+
000834 d008      	rcall	HEX2BIN
         	
000835 2f30      	mov	aux,r16
         
         	; Nibble bajo
000836 910d      	ld	r16,X+
000837 d005      	rcall	HEX2BIN
         	
         	; Unir nibbles:
000838 9532      	swap	aux
000839 7f30      	andi	aux,0xF0
         	
00083a 700f      	andi	r16,0x0F
00083b 2b03      	or	r16,aux
00083c 9508      	ret
         	
         
         
         
         ;----------------------------------------------------
         ;  - HEX2BIN:	Pasa un caracter ascii en r16, y lo 
         ; 	devuelve como valor numerico en el nibble 
         ;	bajo en r16. Si es A..F debe estar en mayusculas
         ;
         ; Al salir: C=0 si todo bien, C=1 si no es digito hex.
         ;----------------------------------------------------
          HEX2BIN:
00083d 3300      	cpi	r16,'0'
00083e f060      	brlo	HEX2BIN_ERR
         	
00083f 3309      	cpi	r16,'9'
000840 f41c      	brge	HEX2BIN_NO_NUM
         
         	; Es un digito numerico:
000841 5300      	subi	r16,'0'
         
000842 9488      	clc
000843 9508      	ret
         	
          HEX2BIN_NO_NUM:
000844 3401      	cpi	r16,'A'
000845 f028      	brlo	HEX2BIN_ERR
         
000846 3407      	cpi	r16,'G'
000847 f41c      	brge	HEX2BIN_ERR
         	
         	; Es digito entre 'A' y 'F':
000848 5307      	subi	r16,('A'-10)
000849 9488      	clc
00084a 9508      	ret
         	
          HEX2BIN_ERR:
         	; ERROR
00084b 2700      	clr	r16
00084c 9408      	sec	
00084d 9508      	ret
         
         
         	
         	
         	
         ;----------------------------------------------------
         ;  CERO_2_X
         ;
         ;  Guarda un byte a 0 en X e incrementa este.
         ;
         ;  Implementado como rutina por que se usa muchas veces
         ;    en el codigo.
         ;----------------------------------------------------
          CERO_2_X:
00084e e000      	ldi	temp,0
00084f 930d      	st	X+,temp
000850 9508      	ret	
         	
         	
         	
         
         
         ;----------------------------------------------------
         ; LCD_R17_BIN2BCD : 2 DIGITOS BCD
         ;  Pasa el numero en r17 a decimal ASCII y lo guarda en X
         ;----------------------------------------------------
          LCD_R17_BIN2BCD:
000851 932f      	push	r18
000852 933f      	push	r19
         	
         	
         	; Dividir r17 entre 10, resultado en r19
000853 2733      	clr	r19
000854 2f21      	mov	r18,r17	; Usar copia de r17 en r18
         	
          lcd_r17_bin2bcd_buc1:
000855 502a      	subi	r18,10
000856 f012      	brmi	lcd_r17_bin2bcd_buc1_fin
000857 9533      	inc	r19
000858 cffc      	rjmp	lcd_r17_bin2bcd_buc1
         
         
          lcd_r17_bin2bcd_buc1_fin:
000859 e00a      	ldi	temp,10
00085a 0f20      	add	r18,temp	; En r18 tenemos las unidades
         
00085b 2333      	tst	r19		; Quitar 0 en decenas si lo hay...
00085c f029      	breq	lcd_r17_bin2bcd_no_decenas
         		
         	; pasar las decenas en r19 a ASCII:
00085d 931f      	push	r17
00085e 2f13      	mov	r17,r19
00085f d218      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
000860 930d      	st	X+,r16	
000861 911f      	pop	r17
         	
          lcd_r17_bin2bcd_no_decenas:
         	
         	; pasar las unidades en r19 a ASCII:
000862 2f12      	mov	r17,r18
000863 d214      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
000864 930d      	st	X+,r16
         
000865 913f      	pop	r19
000866 912f      	pop	r18
000867 9508      	ret
         
         
         ; -------------------------------------------------
         ;   R1_R2_Decimal
         ;
         ;   R1 = HIGH BYTE
         ;   R2 = LOW BYTE
         ;
         ;    Lo escribe en ram en (X)
         ; -------------------------------------------------
          R1_R2_Decimal:
000868 2400      	clr	r0
         	
         ; -------------------------------------------------
         ;   R0_R1_R2_Decimal
         ;
         ;   R0 = +High
         ;   R1 = HIGH BYTE
         ;   R2 = LOW BYTE
         ;
         ;    Lo escribe en ram en (X)
         ; -------------------------------------------------
          R0_R1_R2_Decimal:
         
000869 2477      	clr	r7	; Indicador de todavia todos ceros
         
         
         	; Empezar por las cientos de miles:
         	; -------------------------------------
          r1r2dec_haz_100000:
00086a 2711      	clr	r17	; Contador para digito
         
00086b e021      	ldi	r18, 0x01 ; MSB de 100.000
00086c e836      	ldi	r19, 0x86
00086d ea40      	ldi	r20, 0xA0
         		
          r1r2dec_rst_100000:
         	; Es < 100000 ? Hacer la resta y segun el signo...
00086e 2c40      	mov	r4, r0
00086f 2c51      	mov	r5, r1	
000870 2c62      	mov	r6, r2
         
000871 1a64      	sub	r6, r20
000872 0a53      	sbc	r5, r19
000873 0a42      	sbc	r4, r18
         	
         	; CARRY=1  -> No
000874 f028      	brcs	r1r2dec_fin_100000
         	
         	; Si:
000875 2c04      	mov	r0,r4
000876 2c15      	mov	r1,r5
000877 2c26      	mov	r2,r6
         	
000878 9513      	inc	r17
000879 cff4      	rjmp	r1r2dec_rst_100000
         	
          r1r2dec_fin_100000:
         	
00087a 2311      	tst	r17
00087b f021      	breq	r1r2dec_haz_10000
         
00087c d1fb      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
00087d 930d      	st	X+, r16
00087e ef0f      	ser	r16
00087f 2e70      	mov	r7, r16
         	
         
         
         	; Empezar por las decenas de millas:
         	; -------------------------------------
          r1r2dec_haz_10000:
000880 2711      	clr	r17	; Contador para digito
         
000881 e020      	ldi	r18, 0
000882 e237      	ldi	r19, high ( 10000 ) 
000883 e140      	ldi	r20,  low ( 10000 ) 
         		
          r1r2dec_rst_10000:
         	; Es < 100000 ? Hacer la resta y segun el signo...
000884 2c40      	mov	r4, r0
000885 2c51      	mov	r5, r1	
000886 2c62      	mov	r6, r2
         
000887 1a64      	sub	r6, r20
000888 0a53      	sbc	r5, r19
000889 0a42      	sbc	r4, r18
         	
         	; CARRY=1  -> No
00088a f028      	brcs	r1r2dec_fin_10000
         	
         	; Si:
00088b 2c26      	mov	r2,r6
00088c 2c15      	mov	r1,r5
00088d 2c04      	mov	r0,r4
         	
         	
00088e 9513      	inc	r17
00088f cff4      	rjmp	r1r2dec_rst_10000
         	
          r1r2dec_fin_10000:
000890 fc70      	sbrc	r7, 0
000891 c002      	rjmp	r1r2dec_si_10000
         
000892 2311      	tst	r17
000893 f021      	breq	r1r2dec_haz_1000
         
          r1r2dec_si_10000:
         
000894 d1e3      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
000895 930d      	st	X+, r16
000896 ef0f      	ser	r16
000897 2e70      	mov	r7, r16
         	
         		
         	; Los miles:
         	; -------------------------------------
          r1r2dec_haz_1000:
000898 2711      	clr	r17	; Contador para digito
         
000899 e023      	ldi	r18, high ( 1000 ) 
00089a ee38      	ldi	r19,  low ( 1000 ) 
         		
          r1r2dec_rst_1000:
         	; Es < 1000 ?
00089b 2c41      	mov	r4, r1	
00089c 2c52      	mov	r5, r2
         
00089d 1a53      	sub	r5, r19
00089e 0a42      	sbc	r4, r18
         	
         	; CARRY=1  -> No
00089f f020      	brcs	r1r2dec_fin_1000
         	
         	; Si:
0008a0 2c25      	mov	r2,r5
0008a1 2c14      	mov	r1,r4
         	
0008a2 9513      	inc	r17
0008a3 cff7      	rjmp	r1r2dec_rst_1000
         	
          r1r2dec_fin_1000:
0008a4 fc70      	sbrc	r7, 0
0008a5 c002      	rjmp	r1r2dec_si_1000
         
0008a6 2311      	tst	r17
0008a7 f021      	breq	r1r2dec_haz_100
         
          r1r2dec_si_1000:
0008a8 d1cf      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
0008a9 930d      	st	X+, r16
0008aa ef0f      	ser	r16
0008ab 2e70      	mov	r7, r16
         
         
         	; Centenares:
         	; -------------------------------------
          r1r2dec_haz_100:
0008ac 2711      	clr	r17	; Contador para digito
         
0008ad e020      	ldi	r18, high ( 100 ) 
0008ae e634      	ldi	r19,  low ( 100 ) 
         		
          r1r2dec_rst_100:
         	; Es < 100 ?
0008af 2c41      	mov	r4, r1	
0008b0 2c52      	mov	r5, r2
         
0008b1 1a53      	sub	r5, r19
0008b2 0a42      	sbc	r4, r18
         	
         	; CARRY=1  -> No
0008b3 f020      	brcs	r1r2dec_fin_100
         	
         	; Si:
0008b4 2c25      	mov	r2,r5
0008b5 2c14      	mov	r1,r4
         	
0008b6 9513      	inc	r17
0008b7 cff7      	rjmp	r1r2dec_rst_100
         	
          r1r2dec_fin_100:
0008b8 fc70      	sbrc	r7, 0
0008b9 c002      	rjmp	r1r2dec_si_100
         
0008ba 2311      	tst	r17
0008bb f021      	breq	r1r2dec_haz_10
         
          r1r2dec_si_100:
0008bc d1bb      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
0008bd 930d      	st	X+, r16
0008be ef0f      	ser	r16
0008bf 2e70      	mov	r7, r16
         
         
         
         	; Decenas
         	; -------------------------------------
          r1r2dec_haz_10:
0008c0 2711      	clr	r17	; Contador para digito
         
0008c1 e03a      	ldi	r19, 10
         		
          r1r2dec_rst_10:
         	; Es < 10 ?
0008c2 1623      	cp	r2, r19
0008c3 f01c      	brlt	r1r2dec_fin_10
         
0008c4 1a23      	sub	r2, r19
         	
0008c5 9513      	inc	r17
0008c6 cffb      	rjmp	r1r2dec_rst_10
         	
          r1r2dec_fin_10:
0008c7 fc70      	sbrc	r7, 0
0008c8 c002      	rjmp	r1r2dec_si_10
         
0008c9 2311      	tst	r17
0008ca f021      	breq	r1r2dec_haz_1
         
          r1r2dec_si_10:
0008cb d1ac      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
0008cc 930d      	st	X+, r16
0008cd ef0f      	ser	r16
0008ce 2e70      	mov	r7, r16
         
         
         	; Y las unidades que queden:
          r1r2dec_haz_1:
0008cf 2d12      	mov	r17, r2
         	
0008d0 d1a7      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII	
0008d1 930d      	st	X+, r16
         
         
         
0008d2 9508      	ret
         	
          .include "ata.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: ata.asm
         ;
         ; DESCRIPCION: Protocolo de conexion al disco duro por interfaz
         ;
         ;-----------------------------------------------------------------------------
         
         
         ; Comandos ATA:
         ; --------------------------------------------------------
          .equ	ATA_CMD  = 1
          .equ	ATA_CTRL = 0
         
          .equ	ATA_CTRL_DEVCTRL 	= 0x06 ; Solo escritura
          .equ	ATA_CTRL_ALTSTATUS 	= 0x06 ; Solo lectura
          .equ	ATA_CMD_STATUS  	= 0x07 ; Solo lectura
          .equ	ATA_CMD_COMMAND  	= 0x07 ; Solo escritura
          .equ	ATA_CMD_DEVHEAD 	= 0x06
          .equ	ATA_CMD_CYL_HI		= 0x05
          .equ	ATA_CMD_CYL_LO		= 0x04
          .equ	ATA_CMD_SECNUM  	= 0x03
          .equ	ATA_CMD_SECCNT  	= 0x02
          .equ	ATA_CMD_FEATURES  	= 0x01 ; Solo escritura
          .equ	ATA_CMD_ERROR  		= 0x01 ; Solo lectura
          .equ	ATA_CMD_DATA  		= 0x00 
         
         
         ;-----------------------------------------------------------------------------
         ; SetAddress:
         ;
         ;	r16: direccion de registro a leer 
         ;	r17: 0 = bloque de commandos / 1= bloque de control
         ;
         ;
         ; addressing bits
         ; 35 DA0	A0	0x01	Address Line 0
         ; 33 DA1	A1	0x02	Address Line 1
         ; 36 DA2	A2	0x04	Address Line 2
         ;
         ; chip selects
         ; 37 CS0	A3 	0x08	Command Block Select
         ; 38 CS1	A4	0x10	Control Block Select
         ;	
         ;
         ;	u16 i;
         ;	
         ; 	if (cs==CTRL)  
         ;		i = adr+0x08;		// select A4 low -> CS1 -> CTRL
         ;	else 
         ;		i = adr+0x10;		// select A3 low -> CS0 -> CMD
         ;
         ;	return *(u08 *) (i+0xE000);
         ;-----------------------------------------------------------------------------
          ATA_SetAddress:
0008d3 932f      	push	r18
         
0008d4 7007      	andi	r16, 0x07
         	
         	; A15=1 -> No ram
0008d5 e8b0      	ldi	XH, 0x80
         	
         	; Bit 4=0, correr a la izquierda si direccionamos 
0008d6 e0a8      	ldi	XL, 0x08
0008d7 fd10      	sbrc	r17, 0		; r17=0 -> Comando, dejar A4=0
0008d8 0faa      	lsl	XL		; r17=1 -> Control, poner A3=0
         		
0008d9 2ba0      	or	XL, r16
         	
         	; Hab RAM externa
0008da d251      	rcall	HAB_EXTRAM
0008db 0000      	nop
         
         	; Falsa lectura para poner valores en bus
0008dc 910c      	ld	r16, X
         
         	; Deshab. RAM externa
0008dd d253      	rcall	DESHAB_EXTRAM
         
0008de 912f      	pop	r18
0008df 9508      	ret
         
         
         ;-----------------------------------------------------------------------------
         ;u08 ReadBYTE(u08 cs, u08 adr) 
         ;
         ;	r16: direccion de registro a leer 
         ;	r17: 0 = bloque de commandos / 1= bloque de control
         ;
         ;	-> Salida en r16
         ;
         ;
         ;-----------------------------------------------------------------------------
          ATA_ReadByte:
0008e0 94f8      	cli
         	
0008e1 dff1      	rcall	ATA_SetAddress
         	
0008e2 2700      	clr	temp
0008e3 bb0a      	out	DDRA, temp
         ;	out	DDRC, temp
         	
0008e4 98c1      	cbi	IDE_PORT, IDE_RD
0008e5 0000      	nop
0008e6 b309      	in	r16, PINA	
0008e7 9ac1      	sbi	IDE_PORT, IDE_RD
         
0008e8 9478      	sei
         	
0008e9 9508      	ret	
         
         
         
         ;-----------------------------------------------------------------------------
         ; ATA_WriteByte
         ;
         ;	r16: direccion de registro a leer 
         ;	r17: 0 = bloque de commandos / 1= bloque de control
         ;	r18: Dato a escribir
         ;
         ;-----------------------------------------------------------------------------
          ATA_WriteByte:
0008ea 94f8      	cli
         	
0008eb dfe7      	rcall	ATA_SetAddress
         
0008ec bb2b      	out	PORTA,r18
0008ed ef0f      	ser	temp
0008ee bb0a      	out	DDRA, temp
         	
0008ef 98c0      	cbi	IDE_PORT, IDE_WR
0008f0 0000      	nop		
0008f1 9ac0      	sbi	IDE_PORT, IDE_WR
         	
         ;	clr	temp
         ;	out	DDRA, temp
         	
0008f2 9478      	sei
         	
0008f3 9508      	ret	
         
         ;-----------------------------------------------------------------------------
         ; ATA_SeleccionarDisco
         ;-----------------------------------------------------------------------------
          ATA_SeleccionarDisco:
         	; Esperar a BSY y DRQ = 0, DRDY=1
0008f4 e400      	ldi	r16, 0x40
0008f5 9300 0079 	sts	ATA_WAITMASK_UNOS, r16
0008f7 e808      	ldi	r16, 0x88
0008f8 9300 007a 	sts	ATA_WAITMASK_CEROS, r16
0008fa d008      	rcall	ATA_ESPERA_MASKS
         
0008fb e011      	ldi	r17,ATA_CMD
0008fc e006      	ldi	r16,ATA_CMD_DEVHEAD
0008fd e020      	ldi	r18, 0x00
0008fe dfeb      	rcall	ATA_WriteByte
         	
0008ff e194      	ldi	r25, 20
000900 defe      	rcall	RETARDO_R25_MAX100us
         	
         	; Esperar a BSY y DRQ = 0 (VALORES IGUAL QUE ANTES)
000901 d001      	rcall	ATA_ESPERA_MASKS
         	
000902 9508      	ret
         	
         	
         ;-----------------------------------------------------------------------------
         ; ATA_ESPERA_MASKS
         ;-----------------------------------------------------------------------------
          ATA_ESPERA_MASKS:
000903 e011      	ldi	r17,ATA_CMD
000904 e007      	ldi	r16,ATA_CMD_STATUS
000905 dfda      	rcall	ATA_ReadByte
         
000906 2f10      	mov	r17, r16
         	
         	; Comprobar mascara de ceros:
000907 9120 007a 	lds	r18, ATA_WAITMASK_CEROS
000909 2312      	and	r17, r18	; Solo quedan los bits a testear:
00090a f7c1      	brne	ATA_ESPERA_MASKS ; Alguno != 0 
         	
00090b 2f10      	mov	r17, r16
         	
         	; Comprobar mascara de unos:	
00090c 9120 0079 	lds	r18, ATA_WAITMASK_UNOS	
00090e 2312      	and	r17, r18	; Quitar resto de bits:	
00090f 1712      	cp	r17, r18	; Si son iguales es q estan todos a 1	
000910 f791      	brne	ATA_ESPERA_MASKS ; Alguno != 0 
         	
         	; Se cumplen los ceros y unos, salir:
000911 9508      	ret
         	
         
         
         ;-----------------------------------------------------------------------------
         ;	ATA_ReadSectors
         ;
         ; Parametros:
         ;
         ;	- LBA_DIR: en RAM, numero de sector a leer (en LBA)
         ;	- SECTOR_CNT: Num. de sectores a leer. (max=16)
         ;	- (Y): Apunta a destino de datos en RAM externa.
         ;	
         ;-----------------------------------------------------------------------------
          ATA_ReadSectors:
000912 93bf      	push	XH
000913 93af      	push	XL
         	
         
         	; Esperar a BUSY = 0, DRDY=1
         	; -----------------------------
000914 e400      	ldi	r16, 0x40
000915 9300 0079 	sts	ATA_WAITMASK_UNOS, r16
000917 e800      	ldi	r16, 0x80
000918 9300 007a 	sts	ATA_WAITMASK_CEROS, r16
00091a dfe8      	rcall	ATA_ESPERA_MASKS
         
         
         	; Calcular num. de buffers a rellenar:
00091b e014      	ldi	r17, 512/ATA_TEMP_BUF_TAM ; buffers por sector
         
00091c 9100 0078 	lds	r16, SECTOR_CNT
00091e 2722      	clr	r18
          atardsec_multiplica:
00091f 0f21      	add	r18, r17
000920 950a      	dec	r16
000921 f7e9      	brne	atardsec_multiplica
         	
000922 9320 00fb 	sts	ATA_RDSECT_CUANTOSBUFS, r18
         
         
         	; Mandar parametros
         	; --------------------------------
         	; r18 = 0x40 | LBA[27:24]
000924 e420      	ldi	r18, 0x40	; LBA activado
000925 9100 0077 	lds	r16, LBA_DIR+3
000927 700f      	andi	r16, 0x0F
000928 0f20      	add	r18, r16
000929 e011      	ldi	r17,ATA_CMD
00092a e006      	ldi	r16,ATA_CMD_DEVHEAD
00092b dfbe      	rcall	ATA_WriteByte
         	
         		
         	; r18 = LBA[23:16]
00092c 9120 0076 	lds	r18, LBA_DIR+2
00092e e011      	ldi	r17,ATA_CMD
00092f e005      	ldi	r16,ATA_CMD_CYL_HI
000930 dfb9      	rcall	ATA_WriteByte
         	
         	; r18 = LBA[15:8]
000931 9120 0075 	lds	r18, LBA_DIR+1
000933 e011      	ldi	r17,ATA_CMD
000934 e004      	ldi	r16,ATA_CMD_CYL_LO
000935 dfb4      	rcall	ATA_WriteByte
         	
         	; r18 = LBA[7:0]
000936 9120 0074 	lds	r18, LBA_DIR
000938 e011      	ldi	r17,ATA_CMD
000939 e003      	ldi	r16,ATA_CMD_SECNUM
00093a dfaf      	rcall	ATA_WriteByte
         	
         	; r18 = NUM. SECTORES
00093b 9120 0078 	lds	r18, SECTOR_CNT
00093d e011      	ldi	r17,ATA_CMD
00093e e002      	ldi	r16,ATA_CMD_SECCNT
00093f dfaa      	rcall	ATA_WriteByte
         	
         
         	; Enviar comando de lectura:
         	; -------------------------------
000940 e220      	ldi	r18, 0x20
000941 e011      	ldi	r17,ATA_CMD
000942 e007      	ldi	r16,ATA_CMD_COMMAND
000943 dfa6      	rcall	ATA_WriteByte
         
         
         	; Bucle para cada bloque de buffer interno que se reciba:	
         	; --------------------------------------------------------
         	
         	; Esperar a BUSY = 0 y DRQ=1
          ATA_ReadSectors_read_loop:
000944 e011      	ldi	r17,ATA_CMD
000945 e007      	ldi	r16,ATA_CMD_STATUS
000946 df99      	rcall	ATA_ReadByte
         		
000947 fd07      	sbrc	r16, 7	; BSY=0? Salir del bucle
000948 cffb      	rjmp	ATA_ReadSectors_read_loop
000949 ff03      	sbrs	r16, 3	; DRQ=1? Salir del bucle
00094a cff9      	rjmp	ATA_ReadSectors_read_loop
         
         	
00094b fd00      	sbrc	r16, 0  ; Bit ERR?
00094c c088      	rjmp	ATA_Error
         
00094d ff03      	sbrs	r16, 3  ; DRQ=1 -> Deberia haber datos que recibir !!
00094e c086      	rjmp	ATA_Error
         
         
00094f 94f8      	cli
         		
         	; Poner lineas de direcciones:
000950 e011      	ldi	r17, ATA_CMD
000951 e000      	ldi	r16, ATA_CMD_DATA
000952 df80      	rcall	ATA_SetAddress
         
         	
         	; A y C entradas:
000953 2700      	clr	r16
000954 bb0a      	out	DDRA, r16
000955 bb04      	out	DDRC, r16
         	
         	; Leer el buffer interno:
000956 e0b0      	ldi	XH, high( ATA_TEMP_BUF )
000957 e7ab      	ldi	XL,  low( ATA_TEMP_BUF )
          ata_rd_sect_leer_intbuf:
         ;	cli
         	
         ;	; Poner lineas de direcciones:
         ;	ldi	r17, ATA_CMD
         ;	ldi	r16, ATA_CMD_DATA
         ;	rcall	ATA_SetAddress
         
         
000958 98c1      	cbi	IDE_PORT, IDE_RD
000959 0000      	nop
         	
00095a b309      	in	r16, PINA
00095b b313      	in	r17, PINC
         	
00095c 9ac1      	sbi	IDE_PORT, IDE_RD
         	
         ;	sei	
         	
00095d 930d      	st	X+, r16
00095e 931d      	st	X+, r17
         
         
00095f 3fab      	cpi	XL, low( ATA_TEMP_BUF+ATA_TEMP_BUF_TAM )
000960 f7b9      	brne	ata_rd_sect_leer_intbuf
         	
         
000961 9478      	sei
         	
         	
         	; Y ahora copiar ese buffer a la direccion destino
         	;   en RAM externa:
000962 d1c9      	rcall	HAB_EXTRAM
         	
000963 e0b0      	ldi	XH, high( ATA_TEMP_BUF )
000964 e7ab      	ldi	XL,  low( ATA_TEMP_BUF )
          ata_rd_sect_copia_loop:
000965 910d      	ld	r16, X+
000966 9309      	st	Y+, r16
         
000967 3fab      	cpi	XL, low( ATA_TEMP_BUF+ATA_TEMP_BUF_TAM )
000968 f7e1      	brne	ata_rd_sect_copia_loop
         
         	; Deshab. RAM ext:
000969 d1c7      	rcall	DESHAB_EXTRAM
         
         
         	; Hemos acabado los buffers??
00096a 9100 00fb 	lds	r16, ATA_RDSECT_CUANTOSBUFS
00096c 950a      	dec	r16
00096d 9300 00fb 	sts	ATA_RDSECT_CUANTOSBUFS,r16
         	
00096f f6a1      	brne	ATA_ReadSectors_read_loop
         
         
         
000970 91af      	pop	XL
000971 91bf      	pop	XH	
         	
000972 9508      	ret
         
         
         
         ;-----------------------------------------------------------------------------
         ;	ATA_WriteSectors
         ;
         ; Parametros:
         ;
         ;	- LBA_DIR: en RAM, numero de sector a escribir (en LBA)
         ;	- SECTOR_CNT: Num. de sectores  (max=16)
         ;	- (Y): Apunta a origen de datos en RAM externa.
         ;	
         ;-----------------------------------------------------------------------------
          ATA_WriteSectors:
000973 93bf      	push	XH
000974 93af      	push	XL
         	
         
         	; Esperar a BUSY = 0, DRDY=1
         	; -----------------------------
000975 e400      	ldi	r16, 0x40
000976 9300 0079 	sts	ATA_WAITMASK_UNOS, r16
000978 e800      	ldi	r16, 0x80
000979 9300 007a 	sts	ATA_WAITMASK_CEROS, r16
00097b df87      	rcall	ATA_ESPERA_MASKS
         
         
         	; Calcular num. de buffers a rellenar:
00097c e014      	ldi	r17, 512/ATA_TEMP_BUF_TAM ; buffers por sector
         
00097d 9100 0078 	lds	r16, SECTOR_CNT
00097f 2722      	clr	r18
          atawrsec_multiplica:
000980 0f21      	add	r18, r17
000981 950a      	dec	r16
000982 f7e9      	brne	atawrsec_multiplica
         	
000983 9320 00fb 	sts	ATA_RDSECT_CUANTOSBUFS, r18
         
         
         	; Mandar parametros
         	; --------------------------------
         	; r18 = 0x40 | LBA[27:24]
000985 e420      	ldi	r18, 0x40	; LBA activado
000986 9100 0077 	lds	r16, LBA_DIR+3
000988 700f      	andi	r16, 0x0F
000989 0f20      	add	r18, r16
00098a e011      	ldi	r17,ATA_CMD
00098b e006      	ldi	r16,ATA_CMD_DEVHEAD
00098c df5d      	rcall	ATA_WriteByte
         	
         		
         	; r18 = LBA[23:16]
00098d 9120 0076 	lds	r18, LBA_DIR+2
00098f e011      	ldi	r17,ATA_CMD
000990 e005      	ldi	r16,ATA_CMD_CYL_HI
000991 df58      	rcall	ATA_WriteByte
         	
         	; r18 = LBA[15:8]
000992 9120 0075 	lds	r18, LBA_DIR+1
000994 e011      	ldi	r17,ATA_CMD
000995 e004      	ldi	r16,ATA_CMD_CYL_LO
000996 df53      	rcall	ATA_WriteByte
         	
         	; r18 = LBA[7:0]
000997 9120 0074 	lds	r18, LBA_DIR
000999 e011      	ldi	r17,ATA_CMD
00099a e003      	ldi	r16,ATA_CMD_SECNUM
00099b df4e      	rcall	ATA_WriteByte
         	
         	; r18 = NUM. SECTORES
00099c 9120 0078 	lds	r18, SECTOR_CNT
00099e e011      	ldi	r17,ATA_CMD
00099f e002      	ldi	r16,ATA_CMD_SECCNT
0009a0 df49      	rcall	ATA_WriteByte
         	
         
         	; Enviar comando de Escritura:
         	; -------------------------------
0009a1 e320      	ldi	r18, 0x30
0009a2 e011      	ldi	r17,ATA_CMD
0009a3 e007      	ldi	r16,ATA_CMD_COMMAND
0009a4 df45      	rcall	ATA_WriteByte
         
         
         	; Bucle para cada bloque de buffer interno que se envie:	
         	; --------------------------------------------------------
         	
         	; Esperar a BUSY = 0 y DRQ=1
          ATA_WriteSectors_write_loop:
0009a5 e011      	ldi	r17,ATA_CMD
0009a6 e007      	ldi	r16,ATA_CMD_STATUS
0009a7 df38      	rcall	ATA_ReadByte
         		
0009a8 fd07      	sbrc	r16, 7	; BSY=0? Salir del bucle
0009a9 cffb      	rjmp	ATA_WriteSectors_write_loop
0009aa ff03      	sbrs	r16, 3	; DRQ=1? Salir del bucle
0009ab cff9      	rjmp	ATA_WriteSectors_write_loop
         
         	
0009ac fd00      	sbrc	r16, 0  ; Bit ERR?
0009ad c027      	rjmp	ATA_Error
         
0009ae ff03      	sbrs	r16, 3  ; DRQ=1 -> Deberia estar esperando datos !!
0009af c025      	rjmp	ATA_Error
         
         
0009b0 94f8      	cli
         		
         	
         	; Cargar de mem. externa al bufer interno:
         	; -------------------------------------------
0009b1 d17a      	rcall	HAB_EXTRAM
         	
0009b2 e0b0      	ldi	XH, high( ATA_TEMP_BUF )
0009b3 e7ab      	ldi	XL,  low( ATA_TEMP_BUF )
          ata_wr_sect_copia_loop:
0009b4 9109      	ld	r16, Y+
0009b5 930d      	st	X+, r16
         
0009b6 3fab      	cpi	XL, low( ATA_TEMP_BUF+ATA_TEMP_BUF_TAM )
0009b7 f7e1      	brne	ata_wr_sect_copia_loop
         
         	; Deshab. RAM ext:
0009b8 d178      	rcall	DESHAB_EXTRAM
         
         
         	; Poner lineas de direcciones:
0009b9 e011      	ldi	r17, ATA_CMD
0009ba e000      	ldi	r16, ATA_CMD_DATA
0009bb df17      	rcall	ATA_SetAddress
         	
         	; A y C salidas:
0009bc ef0f      	ser	r16
0009bd bb0a      	out	DDRA, r16
0009be bb04      	out	DDRC, r16
         	
         	
         	; Enviar el buffer interno:
0009bf e0b0      	ldi	XH, high( ATA_TEMP_BUF )
0009c0 e7ab      	ldi	XL,  low( ATA_TEMP_BUF )
         
          ata_wr_sect_envia_intbuf:
0009c1 910d      	ld	r16, X+
0009c2 911d      	ld	r17, X+
         
0009c3 bb0b      	out	PORTA, r16
0009c4 bb15      	out	PORTC, r17
0009c5 0000      	nop
         
0009c6 98c0      	cbi	IDE_PORT, IDE_WR
0009c7 0000      	nop
0009c8 9ac0      	sbi	IDE_PORT, IDE_WR
         	
         
0009c9 3fab      	cpi	XL, low( ATA_TEMP_BUF+ATA_TEMP_BUF_TAM )
0009ca f7b1      	brne	ata_wr_sect_envia_intbuf
         	
         
0009cb 9478      	sei
         	
         
         	; Hemos acabado los buffers??
0009cc 9100 00fb 	lds	r16, ATA_RDSECT_CUANTOSBUFS
0009ce 950a      	dec	r16
0009cf 9300 00fb 	sts	ATA_RDSECT_CUANTOSBUFS,r16
         	
0009d1 f699      	brne	ATA_WriteSectors_write_loop
         
         
0009d2 91af      	pop	XL
0009d3 91bf      	pop	XH	
         	
0009d4 9508      	ret
         	
         	
         ;-----------------------------------------------------------------------------
         ;	ERROR GRAVE:
         ;-----------------------------------------------------------------------------
          ATA_Error:
0009d5 94f8      	cli
         	
0009d6 d04e      	rcall	LCD_BORRAR
         
0009d7 e1f5      	ldi	ZH, high( STR_ATAERR * 2)
0009d8 eae6      	ldi	ZL,  low( STR_ATAERR * 2)
0009d9 d07f      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         	
         	; Leer error:
0009da e011      	ldi	r17,ATA_CMD
0009db e001      	ldi	r16,ATA_CMD_ERROR
0009dc df03      	rcall	ATA_ReadByte
         		
0009dd d08c      	rcall	LCD_ESCRIBE_R16_HEX
         	
         	; Esperar y poner registros:
         ;	ldi	r25, 60
         ;	rcall	RETARDO_R25x25ms
         			
         ;ATA_DEBUG_DumpRegistrosLOOP:
         ;	rcall	ATA_DEBUG_DumpRegistros
         ;	rjmp	ATA_DEBUG_DumpRegistrosLOOP
         	
         ;ATA_DEBUG_DumpRegistrosBLOQ:
         ;	rcall	ATA_DEBUG_DumpRegistros
          atadead:
0009de cfff      	rjmp	atadead	
         	
         	
         	
          .include "lcd.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: LCD.asm
         ;
         ; DESCRIPCION: Implementa rutinas de manejo del LCD
         ;
         ; RUTINAS:
         ; --------
         ;
         ;
         ;	- LCD_INICIAR: Inicializa el diplay
         ;
         ;       - LCD_ESCRIBE_X
         ;
         ;-----------------------------------------------------------------------------
         
         
         ; Caracteres definidos por usuario: 0x01, 0x02, ... 0x07
         ;  Tamaño: 5 x 8 pixels
          .equ	LCD_USERCHARS_CUANTOS = 4
         
          LCD_USERCHARS:
          	.db	$00,$00,$00,$00,$01,$03,$07,$03
0009df 0000
0009e0 0000
0009e1 0301
0009e2 0307
          	.db	$00,$07,$0F,$1F,$1F,$1C,$18,$1C
0009e3 0700
0009e4 1f0f
0009e5 1c1f
0009e6 1c18
          	.db	$01,$01,$03,$07,$0C,$18,$10,$00	
0009e7 0101
0009e8 0703
0009e9 180c
0009ea 0010
          	.db	$1E,$1C,$10,$00,$00,$00,$00,$00	
0009eb 1c1e
0009ec 0010
0009ed 0000
0009ee 0000
         
         
          .equ	LCD_USERCHARS_CUANTOS2 = 7
          LCD_USERCHARS2:
          	.db	$00,$00,$10,$10,$10,$10,$00,$00 ; 0x01 ; Para una barra
0009ef 0000
0009f0 1010
0009f1 1010
0009f2 0000
          	.db	$00,$00,$18,$18,$18,$18,$00,$00 ; 0x02
0009f3 0000
0009f4 1818
0009f5 1818
0009f6 0000
          	.db	$00,$00,$1C,$1C,$1C,$1C,$00,$00 ; 0x03
0009f7 0000
0009f8 1c1c
0009f9 1c1c
0009fa 0000
          	.db	$00,$00,$1E,$1E,$1E,$1E,$00,$00 ; 0x04
0009fb 0000
0009fc 1e1e
0009fd 1e1e
0009fe 0000
          	.db	$00,$00,$1F,$1F,$1F,$1F,$00,$00 ; 0x05
0009ff 0000
000a00 1f1f
000a01 1f1f
000a02 0000
         	
          	.db	$00,$00,$1F,$11,$11,$11,$1F,$00 ; 0x06 ; Cuadro con y sin marcar
000a03 0000
000a04 111f
000a05 1111
000a06 001f
          	.db	$00,$00,$1F,$1B,$15,$1B,$1F,$00 ; 0x07
000a07 0000
000a08 1b1f
000a09 1b15
000a0a 001f
         
         
         
         ;--------------------------------------------------------
         ;	LCD_INICIAR
         ;--------------------------------------------------------
          LCD_INICIAR:
         
         	; Iniciar el LCD 3 veces como recomiendan los fabricantes:
         	; ---------------------------------------------------------
         	
000a0b e013      	ldi	conta,3	
         	
          lcd_init_bucle:	
000a0c e300      	ldi	r16,$30
000a0d d01d      	rcall	LCD_TX_COMANDO
         		
         	; Retardo de proceso de comando:200ms
000a0e e095      	ldi	r25, 5
000a0f ddf9      	rcall	RETARDO_R25x25ms
         	
000a10 951a      	dec	conta
000a11 f7d1      	brne	lcd_init_bucle
         
         	; Activar modo de 2 lineas:
000a12 e308      	ldi	r16,$38
000a13 d017      	rcall	LCD_TX_COMANDO
         	
         	; Borrar pantalla:
000a14 d010      	rcall	LCD_BORRAR
         	
         	; Activar display y cursor off
000a15 e00c      	ldi	r16,$0C
000a16 d014      	rcall	LCD_TX_COMANDO
         	
         
000a17 e230      	ldi	aux, 8*LCD_USERCHARS_CUANTOS
000a18 e1f3      	ldi	ZH, high( LCD_USERCHARS*2 )
000a19 ebee      	ldi	ZL,  low( LCD_USERCHARS*2 )
         	
000a1a d001      	rcall	LCD_CARGA_CARACTERES
         	
         	
000a1b 9508      	ret
         	
         
         	
         ;--------------------------------------------------------
         ;  LCD_CARGA_CARACTERES
         ;
         ;  (Z) y aux
         ;  Primer caracter = 0x01
         ;--------------------------------------------------------
          LCD_CARGA_CARACTERES:
         	; Cargar caracteres definidos por usuario:
000a1c e408      	ldi	r16, 0x48	; Caracter 1 el primero def. x usuario
000a1d d00d      	rcall	LCD_TX_COMANDO
         
          lcdcrgchar_lp:
000a1e 95c8      	lpm		
000a1f 9631      	adiw	ZL, 1
000a20 2d00      	mov	r16, r0
000a21 d012      	rcall	LCD_TX_DATO
         	
000a22 953a      	dec	aux
000a23 f7d1      	brne	lcdcrgchar_lp
         	
         	
000a24 9508      	ret
         	
         
         ;--------------------------------------------------------
         ;	LCD_BORRAR
         ;--------------------------------------------------------
          LCD_BORRAR:
000a25 e001      	ldi	r16,$01
000a26 c004      	rjmp	LCD_TX_COMANDO
         
         ;--------------------------------------------------------
         ;	LCD_SCROLL_ON
         ;--------------------------------------------------------
          LCD_SCROLL_ON:
000a27 e007      	ldi	r16,0x07
000a28 c002      	rjmp	LCD_TX_COMANDO
         
         ;--------------------------------------------------------
         ;	LCD_SCROLL_OFF
         ;--------------------------------------------------------
          LCD_SCROLL_OFF:
000a29 e006      	ldi	r16,0x06
000a2a c000      	rjmp	LCD_TX_COMANDO
         	
         
         ;--------------------------------------------------------
         ;	LCD_TX_COMANDO
         ;
         ; Envia un byte en r16 al LCD como comando
         ;--------------------------------------------------------
          LCD_TX_COMANDO:
         	; RS=0, E=0, RW=0, datos = r16
         	
000a2b bb0b      	out	PORTA, r16
         	
000a2c ef0f      	ser	r16
000a2d bb0a      	out	DDRA,r16
000a2e bb04      	out	DDRC,r16
         	
000a2f e000      	ldi	r16, 0x00
000a30 bb05      	out	PORTC, r16
         	
         		
         	; Dar pulso en E:
000a31 d01e      	rcall	LCD_PULSO_E
000a32 d00a      	rcall	LCD_WAIT_BUSY	
         	
000a33 9508      	ret
         
         	
         ;--------------------------------------------------------
         ;	LCD_TX_DATO
         ;
         ; Envia un byte en r16 al LCD como caracter
         ;--------------------------------------------------------
          LCD_TX_DATO:
         	; RS=1, E=0, RW=0, datos = r16
000a34 bb0b      	out	PORTA, r16
         	
000a35 ef0f      	ser	r16
000a36 bb0a      	out	DDRA,r16
000a37 bb04      	out	DDRC,r16
         	
000a38 e001      	ldi	r16, 0x01
000a39 bb05      	out	PORTC, r16
         	
         	; Dar pulso en E:
000a3a d015      	rcall	LCD_PULSO_E
000a3b d001      	rcall	LCD_WAIT_BUSY	
         	
000a3c 9508      	ret
         	
         	
         ;--------------------------------------------------------
         ;  LCD_WAIT_BUSY
         ;
         ;  Desactivo RAM externa para leer el byte de estado del
         ;    display:
         ;
         ;--------------------------------------------------------
          LCD_WAIT_BUSY:
         	; Preparar contenido del PORTC: 
         	;  A15(CS de RAM)=1
         	;  A9=1 R/W
         	;  A8=0 RS
000a3d e802      	ldi	temp, 0b10000010
000a3e bb05      	out	PORTC, temp
000a3f ef0f      	ser	temp
000a40 bb04      	out	DDRC, temp
         
         	; Preparar PORTA como entrada:
000a41 2700      	clr	temp
000a42 bb0a      	out	DDRA, temp
000a43 bb0b      	out	PORTA, temp
         		
         	; POLL hasta que bit 7 sea 0
          LCD_WAIT_BUSY_loop:
         	
         	; E=1
000a44 9a95      	sbi	PORTD, 5
         	
000a45 e298      	ldi	r25, 40
000a46 ddb8      	rcall	RETARDO_R25_MAX100us
         	
         	; Busy??
000a47 b329      	in	temp2, PINA
         	
         	; E=0
000a48 9895      	cbi	PORTD, 5
         
         	; Fin?
000a49 ff27      	sbrs	temp2, 7
000a4a c003      	rjmp	LCD_WAIT_BUSY_fin	; Solo si bit 7 = 0
         	
         	; retardo y a seguir:
000a4b e298      	ldi	r25, 40
000a4c ddb2      	rcall	RETARDO_R25_MAX100us
000a4d cff6      	rjmp	LCD_WAIT_BUSY_loop
         
         
          LCD_WAIT_BUSY_fin:	
         	; Y dejar E=0:
000a4e 9895      	cbi	PORTD, 5
         	
000a4f 9508      	ret
         
         ;--------------------------------------------------------
         ;	LCD_PULSO_E
         ;
         ;  Dar pulso en E: Se supone X es lo q hay en el bus 
         ;    y que XH=0x8X
         ;--------------------------------------------------------
          LCD_PULSO_E:
000a50 e392      	ldi	r25,50
000a51 ddad      	rcall	RETARDO_R25_MAX100us		; aprox. 1.5us
         	
000a52 9a95      	sbi	PORTD, 5
         
000a53 e392      	ldi	r25,50
000a54 ddaa      	rcall	RETARDO_R25_MAX100us		; aprox. 1.5us
         
000a55 9895      	cbi	PORTD, 5
         
000a56 e392      	ldi	r25,50
000a57 dda7      	rcall	RETARDO_R25_MAX100us		; aprox. 1.5us
         	
000a58 9508      	ret
         	
         
         
         ;----------------------------------------------------
         ; LCD_ESCRIBE_CADENA_Z_FLASH
         ;
         ;  Escribe una cadena de bytes terminada en 0, 
         ;   almacenada en flash en direccion Z
         ;----------------------------------------------------
          LCD_ESCRIBE_CADENA_Z_FLASH:
000a59 930f      	push	r16
000a5a 920f      	push	r0
         	
          lcd_esc_cad_bucl:
         	; Cargar un byte de flash:
000a5b 95c8      	lpm
000a5c 2d00      	mov	r16,r0
000a5d 2300      	tst	r16			; 0=fin de cadena
000a5e f019      	breq	lcd_esc_cad_fin
         	
000a5f dfd4      	rcall	LCD_TX_DATO		; Escribir caracter
         	; Incrementar contador Z:
000a60 9631      	adiw	ZL,1
000a61 cff9      	rjmp	lcd_esc_cad_bucl
         
         
          lcd_esc_cad_fin:
000a62 900f      	pop	r0
000a63 910f      	pop	r16
000a64 9508      	ret
         
         ;----------------------------------------------------
         ;  LCD_SET_CURSOR_POS_R16
         ;
         ;	Mueve el cursor a la posicion del LCD "r16"
         ;
         ; 1º linea: $00 a $0F
         ; 2º linea: $40 a $4F
         ;----------------------------------------------------
          LCD_SET_CURSOR_POS_R16:
000a65 930f      	push	r16
000a66 6800      	ori	r16,$80		;instruccion : 0b1XXXXXX
         	
000a67 dfc3      	rcall	LCD_TX_COMANDO
         	
000a68 910f      	pop	r16
000a69 9508      	ret
         
         
         ;----------------------------------------------------
         ;           LCD_ESCRIBE_R16_HEX
         ;
         ;  Escribe dos digitos en hexadecimal de valor (r16)
         ;----------------------------------------------------
          LCD_ESCRIBE_R16_HEX:
000a6a 931f      	push	r17
000a6b 930f      	push	r16
         
000a6c 2f10      	mov	r17,r16	; Guardar byte a mostrar en r16
         
         	; Nibble superior:	
000a6d 9512      	swap	r17
000a6e d009      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII
000a6f dfc4      	rcall	LCD_TX_DATO
         	
         	; Nibble inferior:
000a70 910f      	pop	r16
000a71 930f      	push	r16
000a72 2f10      	mov	r17,r16	; Guardar byte a mostrar en r16
         
000a73 d004      	rcall	LCD_LOW_NIBBLE_R17_2_R16_ASCII
000a74 dfbf      	rcall	LCD_TX_DATO
         
000a75 910f      	pop	r16
000a76 911f      	pop	r17
000a77 9508      	ret
         
         ;--------------------------------------------------------
         ; Rutina auxiliar: Modifica el valor en r17 
         ;--------------------------------------------------------
          LCD_LOW_NIBBLE_R17_2_R16_ASCII:
000a78 932f      	push	r18
         	
000a79 701f      	andi	r17,0x0F
         	; Tratar como si fuese digito 0-9:
000a7a e300      	ldi	r16,'0'
000a7b 0f01      	add	r16,r17
         	
         	; Ver si se trata de A-F:
000a7c e02a      	ldi	r18,10
000a7d 1712      	cp	r17,r18
000a7e f01a      	brmi	fin_r17_2_r16_asc	; Saltar si NUM-10 < 0 -> NUM < 10
         	
         	; Es una letra:	
000a7f 501a      	subi	r17,10
000a80 e401      	ldi	r16,'A'
000a81 0f01      	add	r16,r17	
         
         
          fin_r17_2_r16_asc:
000a82 912f      	pop	r18
000a83 9508      	ret
         
         
         
         ;-------------------------------------------------------
         ;           LCD_ESCRIBE_X
         ;
         ;  Escribe desde memoria (int / ext) (X), acaba con 0x00
         ;-------------------------------------------------------
          LCD_ESCRIBE_X:
         ;	rcall	HAB_EXTRAM
000a84 910d      	ld	r16, X+
         	
000a85 2300      	tst	r16
000a86 f011      	breq	LCD_ESCRIBE_X_FIN
         	
         ;	rcall	DESHAB_EXTRAM
000a87 dfac      	rcall	LCD_TX_DATO
         	
000a88 cffb      	rjmp	LCD_ESCRIBE_X
         	
          LCD_ESCRIBE_X_FIN:
000a89 9508      	ret
         	
         	
         ;-------------------------------------------------------
         ;	Escribe texto de X, offset en r17, hasta un 
         ;   maximo de r18 caracteres o 0x00 en cadena
         ;-------------------------------------------------------
          LCD_ESC_X_OFF_R17_MAX_R18:
000a8a 2400      	clr	r0
000a8b 0fa1      	add	XL, r17
000a8c 1db0      	adc	XH, r0
         
          LCD_ESC_X_OFF_R17_MAX_R18_lp:
000a8d 910d      	ld	r16, X+
         	
000a8e 2300      	tst	r16
000a8f f029      	breq	LCD_ESCRIBE_X_OFF_FIN
         
000a90 932f      	push	r18	
000a91 dfa2      	rcall	LCD_TX_DATO
000a92 912f      	pop	r18
         	
000a93 952a      	dec	r18
000a94 f7c1      	brne 	LCD_ESC_X_OFF_R17_MAX_R18_lp
         	
         	
          LCD_ESCRIBE_X_OFF_FIN:
000a95 9508      	ret
         
         
         
         
         ;-------------------------------------------------------
         ;  LCD_ESCRIBE_ABAJO_DERECHA_X
         ;
         ;  Escribe alineado abajo a la derecha el texto en (X)
         ;-------------------------------------------------------
          LCD_ESCRIBE_ABAJO_DERECHA_X:
000a96 e0b0      	ldi	XH, high ( STR_BUF )
000a97 e6a0      	ldi	XL,  low ( STR_BUF )
000a98 d0a1      	rcall	STRLEN
000a99 e410      	ldi	r17, 0x40
000a9a e124      	ldi	r18, ANCHO_LCD
000a9b 0f12      	add	r17, r18
000a9c 1b10      	sub	r17, r16
000a9d 2f01      	mov	r16, r17
000a9e dfc6      	rcall	LCD_SET_CURSOR_POS_R16
         	
000a9f e0b0      	ldi	XH, high ( STR_BUF )
000aa0 e6a0      	ldi	XL,  low ( STR_BUF )
000aa1 cfe2      	rjmp	LCD_ESCRIBE_X
         
         
         ; -----------------------------------
         ;  LCD_BORRAR_LINEA
         ;
         ;   Borra linea actual
         ; -----------------------------------
          LCD_BORRAR_LINEA:	
000aa2 e124      	ldi	r18, ANCHO_LCD
          lcdbrlin_lp:		
000aa3 e200      	ldi	r16, ' '
000aa4 932f      	push	r18
         	
000aa5 df8e      	rcall	LCD_TX_DATO
         	
000aa6 912f      	pop	r18
         	
000aa7 952a      	dec	r18
000aa8 f7d1      	brne	lcdbrlin_lp
         	
000aa9 9508      	ret
          .include "textos.asm"
         ;----------------------------------------------------
         ; FICHERO: Textos.asm
         ;
         ; DESCRIPCION: Para declarar cadenas de texto
         ;
         ; Jose Luis Blanco Claraco @ 2001-2002
         ;----------------------------------------------------
         
         
          PRIMERA_PANTALLA1: 
         ;	.db $01,$02,"   GigaMP3  ",$01,$02,0,0
          	.db $01,$02,"       GigaMP3    ",0,0
000aaa 0201
000aab 2020
000aac 2020
000aad 2020
000aae 4720
000aaf 6769
000ab0 4d61
000ab1 3350
000ab2 2020
000ab3 2020
000ab4 0000
          PRIMERA_PANTALLA2: 
         ;	.db $03,$04," JLBC @2003 ",$03,$04,0,0
          	.db $03,$04," Jose Luis B. '03 ",0,0
000ab5 0403
000ab6 4a20
000ab7 736f
000ab8 2065
000ab9 754c
000aba 7369
000abb 4220
000abc 202e
000abd 3027
000abe 2033
000abf 0000
         
          STR_CHK_RAM: 
          	.db "32 Kb RAM...",0,0
000ac0 3233
000ac1 4b20
000ac2 2062
000ac3 4152
000ac4 2e4d
000ac5 2e2e
000ac6 0000
         
          STR_TSTHD: 
          	.db "Reset disco...",0,0
000ac7 6552
000ac8 6573
000ac9 2074
000aca 6964
000acb 6373
000acc 2e6f
000acd 2e2e
000ace 0000
         	
          STR_OK: 
          	.db "OK",0,0
000acf 4b4f
000ad0 0000
          STR_ER: 
          	.db "ER",0,0
000ad1 5245
000ad2 0000
         	
          STR_ATAERR:
          	.db "ATA ERROR:",0,0 
000ad3 5441
000ad4 2041
000ad5 5245
000ad6 4f52
000ad7 3a52
000ad8 0000
         	
          STR_FATERR:
          	.db "FAT ERROR!",0,0 
000ad9 4146
000ada 2054
000adb 5245
000adc 4f52
000add 2152
000ade 0000
         
          STR_USB:
          	.db "** Modo USB **",0,0
000adf 2a2a
000ae0 4d20
000ae1 646f
000ae2 206f
000ae3 5355
000ae4 2042
000ae5 2a2a
000ae6 0000
         
          STR_NO_DIR:
          	.db "No direct. valido!",0,0
000ae7 6f4e
000ae8 6420
000ae9 7269
000aea 6365
000aeb 2e74
000aec 7620
000aed 6c61
000aee 6469
000aef 216f
000af0 0000
          STR_NO_MP3s:
          	.db "No hay fichs MP3!", 0
000af1 6f4e
000af2 6820
000af3 7961
000af4 6620
000af5 6369
000af6 7368
000af7 4d20
000af8 3350
000af9 0021
         	
         ; Textos de menus:
         ; --------------------------
          .equ	NUM_MENUS	=  5
         
000afa      MNU_1: .db "Repr. directorio",0,0
000afa 6552
000afb 7270
000afc 202e
000afd 6964
000afe 6572
000aff 7463
000b00 726f
000b01 6f69
000b02 0000
000b03      MNU_2: .db "Repr. dir. aleat",0,0
000b03 6552
000b04 7270
000b05 202e
000b06 6964
000b07 2e72
000b08 6120
000b09 656c
000b0a 7461
000b0b 0000
000b0c      MNU_3: .db "Mejorar bajos",0
000b0c 654d
000b0d 6f6a
000b0e 6172
000b0f 2072
000b10 6162
000b11 6f6a
000b12 0073
000b13      MNU_4: .db "Virtual sorround",0,0
000b13 6956
000b14 7472
000b15 6175
000b16 206c
000b17 6f73
000b18 7272
000b19 756f
000b1a 646e
000b1b 0000
000b1c      MNU_5: .db "Config. mando",0
000b1c 6f43
000b1d 666e
000b1e 6769
000b1f 202e
000b20 616d
000b21 646e
000b22 006f
         
         
          .include "utils.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: utils.asm
         ;
         ; DESCRIPCION: 
         ;
         ;
         ;-----------------------------------------------------------------------------
         
         ;------------------------------------------------
         ;  GENERAR_PSEUDOALEAT
         ;------------------------------------------------
          GENERAR_PSEUDOALEAT:
         	; Generar valor pseudoaleatorio	
000b23 b612      	in	r1, TCNT0
000b24 9109      	ld	r16, Y+
000b25 2501      	eor	r16, r1
000b26 9508      	ret
         
         ;--------------------------------------------------------
         ; R16_MODULO_R2
         ; 
         ;  Devuelve en r16 = r16 mod r2
         ;--------------------------------------------------------
          R16_MODULO_R2:
000b27 1502      	cp	r16, r2
000b28 f010      	brlo	R16_MODULO_R2_fin
         	
         	; Restar:	
000b29 1902      	sub	r16, r2
000b2a cffc      	rjmp	R16_MODULO_R2
         	
          R16_MODULO_R2_fin:
000b2b 9508      	ret
         
         ;--------------------------------------------------------
         ; HAB_EXTRAM
         ;--------------------------------------------------------
          HAB_EXTRAM:
000b2c 930f      	push	r16
         	
000b2d e800      	ldi	r16,0x80
          HAB_EXTRAM_IN:
000b2e bf05      	out	MCUCR,r16
         	
000b2f 910f      	pop	r16
000b30 9508      	ret
         
         ;--------------------------------------------------------
         ; DESHAB_EXTRAM
         ;--------------------------------------------------------
          DESHAB_EXTRAM:
000b31 930f      	push	r16
000b32 2700      	clr	r16
000b33 cffa      	rjmp	HAB_EXTRAM_IN
         
         ;--------------------------------------------------------
         ; COPIAR_X_2_Y_R18_BYTES
         ;--------------------------------------------------------
          COPIAR_X_2_Y_32bits:
000b34 e024      	ldi	r18, 4
          COPIAR_X_2_Y_R18_BYTES:
000b35 910d      	ld	r16, X+
000b36 9309      	st	Y+,r16
         	
000b37 952a      	dec	r18
000b38 f7e1      	brne	COPIAR_X_2_Y_R18_BYTES
         	
000b39 9508      	ret
         	
         	
         ;--------------------------------------------------------
         ;  Devuelve en r16 longitud de la cadena hasta 0x00 (no inc)
         ;    apuntada por X:
         ;--------------------------------------------------------
          STRLEN:
000b3a 2700      	clr	r16
         	
          STRLEN_LOOP:
000b3b 911d      	ld	r17, X+
000b3c 2311      	tst	r17
000b3d f011      	breq	STRLEN_FIN
         	
000b3e 9503      	inc	r16
         	
000b3f cffb      	rjmp	STRLEN_LOOP
         	
          STRLEN_FIN:
000b40 9508      	ret
         
         	
         ; ----------------------------------------------------
         ;  CALCULA_MINUTOS
         ;
         ; Devuelve en r1:r0 ( MSB:LSB ) el numero de minutos enteros
         ;  a partir del numero de segundos en r18:r19
         ; En r19 deja el numero de segundos que sobran
         ; ----------------------------------------------------
          CALCULA_MINUTOS:
000b41 2400      	clr	r0
         
000b42 2411      	clr	r1
000b43 2422      	clr	r2
000b44 e30c      	ldi	r16, 60
          calcmins_lp:
         	; Es r18:r19 > 60 ?
000b45 2322      	tst	r18
000b46 f419      	brne	calcmins_rst_60	; Si es > 256 si lo es :-)
         	
000b47 1730      	cp	r19, r16
000b48 f408      	brsh	calcmins_rst_60
         	
         	; No, se acabo:
000b49 9508      	ret
         	
         
         	; Si es > 60:
          calcmins_rst_60:	
         	; Incrementar numero de minutos
000b4a e011      	ldi	r17, 0x01
000b4b 0e21      	add	r2, r17
000b4c 1c10      	adc	r1, r0
         	
         	; Y restar al num. de segundos:
000b4d 1b30      	sub	r19, r16
000b4e 0920      	sbc	r18, r0
         	
000b4f cff5      	rjmp	calcmins_lp
         	
         	
         		
         	
         
         
000b50 9508      	ret
          .include "vs1001.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: vs1001.asm
         ;
         ; DESCRIPCION: Comunicacion con chip decodificador de MP3: VS1001k
         ;
         ;
         ;-----------------------------------------------------------------------------
         
         
         
          .equ	VS1001_CONFIG_XTAL	= 	0x9BEE	; 14.3 Mhz x 2
         
         					;0x9388  ; Valor para 10 Mhz
         
         
          .equ	VS1001ADDR_MODE		= 0
          .equ	VS1001ADDR_STATUS	= 1
          .equ	VS1001ADDR_INT_FNTLH	= 2
          .equ	VS1001ADDR_CLOCKF	= 3
          .equ	VS1001ADDR_DECODE_TIME	= 4
          .equ	VS1001ADDR_AUDATA	= 5
          .equ	VS1001ADDR_WRAM		= 6
          .equ	VS1001ADDR_WRAMADDR	= 7
          .equ	VS1001ADDR_HDAT0	= 8
          .equ	VS1001ADDR_HDAT1	= 9
          .equ	VS1001ADDR_AIADDR	= 10
          .equ	VS1001ADDR_VOL		= 11
         
         
         ;--------------------------------------------------------
         ;  VS1001_INICIAR
         ;--------------------------------------------------------
          VS1001_INICIAR:
         	; DREQ entrada, tiron
000b51 98ba      	cbi	VS1001_DDR, VS1001_DREQ
000b52 9ac2      	sbi	VS1001_PORT, VS1001_DREQ
         	
         	; BSYNC salida, a cero
000b53 9abb      	sbi	VS1001_DDR, VS1001_BSYNC
000b54 98c3      	cbi	VS1001_PORT, VS1001_BSYNC
         	
         	; VS1001_MP3CS salida, a uno ahora: Deshabilitado
000b55 9abc      	sbi	VS1001_DDR, VS1001_MP3CS
000b56 9ac4      	sbi	VS1001_PORT, VS1001_MP3CS
         	
         	; MOSI , SS y SCK salida:
000b57 9abc      	sbi	DDRB, 4 ; SS
000b58 9abd      	sbi	DDRB, 5 ; MOSI
000b59 9abf      	sbi	DDRB, 7 ; SCK
         	
000b5a 98c7      	cbi	PORTB, 7; SCK = 0
         	
         	
         	; Configurar SPI:
         	;
         	;	CLK= osc / 4 	(2 Mhz)
         	;	Fase reloj = positiva y 
         	;	Modo: MASTER
         	;	Activar SPI!!	
000b5b e500      	ldi	r16, 0b01010000
000b5c b90d      	out	SPCR, r16
         	
         	
         	; Quitar posibles bytes recibidos, etc...
000b5d b10e      	in	r16, SPSR	
         
         
         
000b5e 9508      	ret
         	
         
         ;--------------------------------------------------------
         ;  VS1001_ESPERA_TX_LIBRE
         ;
         ;  Rutina auxiliar que espera a que termine la 
         ;   transmision/recepcion de un byte por SPI:
         ;--------------------------------------------------------
          VS1001_ESPERA_TX_LIBRE:
000b5f 9b77      	sbis	SPSR, SPIF
000b60 cffe      	rjmp	VS1001_ESPERA_TX_LIBRE
         	
000b61 9508      	ret
         
         	
         ;--------------------------------------------------------
         ;  VS1001_ESC_REGISTRO
         ;
         ;   r17: Direccion
         ;   r18/r19: Bytes a enviar (Alto / bajo)
         ;--------------------------------------------------------
          VS1001_ESC_REGISTRO:
         	; Seleccionar chip: xCS = 0
000b62 98c4      	cbi	VS1001_PORT, VS1001_MP3CS
         	
         	; Comando: WRITE
000b63 e002      	ldi	r16, 0x02
000b64 b90f      	out	SPDR, r16
000b65 dff9      	rcall	VS1001_ESPERA_TX_LIBRE
         	
         	; Direccion:
000b66 b91f      	out	SPDR, r17
000b67 dff7      	rcall	VS1001_ESPERA_TX_LIBRE
         	
         	; Byte alto:
000b68 b92f      	out	SPDR, r18
000b69 dff5      	rcall	VS1001_ESPERA_TX_LIBRE
         			
         	; Byte bajo:	
000b6a b93f      	out	SPDR, r19
000b6b dff3      	rcall	VS1001_ESPERA_TX_LIBRE
         		
         
         	; De - seleccionar chip: xCS = 1
000b6c 9ac4      	sbi	VS1001_PORT, VS1001_MP3CS
         	
         		
         	
         	; Retardo para asegurar que no se escribe 
         	;  datos MPEG hasta 5us despues!!
000b6d e09f      	ldi	r25, 15
000b6e dc90      	rcall	RETARDO_R25_MAX100us
         
000b6f 9508      	ret
         	
         	
         ;--------------------------------------------------------
         ;  VS1001_LEE_REGISTRO
         ;
         ;   r17: Direccion
         ;
         ;   r18/r19: Bytes leidos (Alto / bajo)
         ;--------------------------------------------------------
          VS1001_LEE_REGISTRO:
         	; Seleccionar chip: xCS = 0
000b70 98c4      	cbi	VS1001_PORT, VS1001_MP3CS
         	
         	; Comando: READ
000b71 e003      	ldi	r16, 0x03
000b72 b90f      	out	SPDR, r16
000b73 dfeb      	rcall	VS1001_ESPERA_TX_LIBRE
         	
         	; Direccion:
000b74 b91f      	out	SPDR, r17
000b75 dfe9      	rcall	VS1001_ESPERA_TX_LIBRE
         	
         	; Byte alto:
000b76 e000      	ldi	r16, 0x00
000b77 b90f      	out	SPDR, r16
000b78 dfe6      	rcall	VS1001_ESPERA_TX_LIBRE
000b79 b12f      	in	r18, SPDR
         			
         	; Byte bajo:	
000b7a e000      	ldi	r16, 0x00
000b7b b90f      	out	SPDR, r16
000b7c dfe2      	rcall	VS1001_ESPERA_TX_LIBRE
000b7d b13f      	in	r19, SPDR
         		
         
         	; De - seleccionar chip: xCS = 1
000b7e 9ac4      	sbi	VS1001_PORT, VS1001_MP3CS
         	
         	
         	; Retardo para asegurar que no se escribe 
         	;  datos MPEG hasta 5us despues!!
000b7f e09f      	ldi	r25, 15
000b80 dc7e      	rcall	RETARDO_R25_MAX100us
         
000b81 9508      	ret
         	
         	
         
         ;--------------------------------------------------------
         ;  VS1001_TX_MPEG_DATA
         ;
         ;   r16: Dato
         ;--------------------------------------------------------
          VS1001_TX_MPEG_DATA:
         	; Sinc. de byte
000b82 9ac3      	sbi	VS1001_PORT, VS1001_BSYNC
         	
000b83 b90f      	out	SPDR, r16
         	
000b84 0000      	nop
000b85 0000      	nop
000b86 0000      	nop
         	
         	; Ya esta bien
000b87 98c3      	cbi	VS1001_PORT, VS1001_BSYNC
         	
         	; Esperar final:
000b88 dfd6      	rcall	VS1001_ESPERA_TX_LIBRE
         		
         
000b89 9508      	ret
         	
         
         ;--------------------------------------------------------
         ;  VS1001_TX_MPEG_DATA_32X
         ;
         ;   (X): 32 bytes de datos a mandar
         ;--------------------------------------------------------
          VS1001_TX_MPEG_DATA_32X:
000b8a 932f      	push	r18
         	
         	; Sinc. de byte
000b8b 9ac3      	sbi	VS1001_PORT, VS1001_BSYNC
         	
000b8c e220      	ldi	r18, 32
          vs1001_tx32_loop:
000b8d 910d      	ld	r16, X+
000b8e b90f      	out	SPDR, r16
000b8f dfcf      	rcall	VS1001_ESPERA_TX_LIBRE
         	
000b90 952a      	dec	r18
000b91 f7d9      	brne	vs1001_tx32_loop
         
         	; Ya esta bien
000b92 98c3      	cbi	VS1001_PORT, VS1001_BSYNC		
         
000b93 912f      	pop	r18
000b94 9508      	ret
         	
         
         
         ;--------------------------------------------------------
         ;  VS1001_RESET
         ;
         ;--------------------------------------------------------
          VS1001_RESET:
         	; Enviar ceros para asegurar fin de cancion
000b95 e430      	ldi	r19, 2048/32
000b96 d01b      	rcall	VS1001_TX_R19x32_CEROS
         	
         	; Retardo: Grande por si es bitrate bajo :-(
         ;	ldi	r25, 18
000b97 e098      	ldi	r25, 8
000b98 dc70      	rcall	RETARDO_R25x25ms
         
         	; Reset SW:	
         	; ------------------------------------------------------------
000b99 e010      	ldi	r17, VS1001ADDR_MODE
000b9a e020      	ldi	r18, 0x00
000b9b e034      	ldi	r19, 0x04
000b9c dfc5      	rcall	VS1001_ESC_REGISTRO
         	
         	; Retardo
000b9d e093      	ldi	r25, 3
000b9e dc6a      	rcall	RETARDO_R25x25ms
         
         	; Asegurar DREQ=1 ( Preparado para decodificar )
          vs1001_reset_esp_dreq:
000b9f 9bb2      	sbis	VS1001_PIN, VS1001_DREQ
000ba0 cffe      	rjmp	vs1001_reset_esp_dreq
         	
000ba1 e092      	ldi	r25, 2
000ba2 dc66      	rcall	RETARDO_R25x25ms
         		
         	; Configurar cristal:
000ba3 e013      	ldi	r17, VS1001ADDR_CLOCKF
000ba4 e92b      	ldi	r18, high ( VS1001_CONFIG_XTAL )
000ba5 e93b      	ldi	r19, high ( VS1001_CONFIG_XTAL )
000ba6 dfbb      	rcall	VS1001_ESC_REGISTRO
         
000ba7 e092      	ldi	r25, 2
000ba8 dc60      	rcall	RETARDO_R25x25ms
         
         	; Configurar cristal:
000ba9 e013      	ldi	r17, VS1001ADDR_CLOCKF
000baa e92b      	ldi	r18, high ( VS1001_CONFIG_XTAL )
000bab e93b      	ldi	r19, high ( VS1001_CONFIG_XTAL )
000bac dfb5      	rcall	VS1001_ESC_REGISTRO
         
000bad e092      	ldi	r25, 2
000bae dc5a      	rcall	RETARDO_R25x25ms
         
         	; Enviar algunos ceros para retrasar al chip
000baf e230      	ldi	r19, 1024/32
000bb0 d001      	rcall	VS1001_TX_R19x32_CEROS
         	
000bb1 9508      	ret
         	
         
         
         ;--------------------------------------------------------
         ; VS1001_TX_R19x32_CEROS
         ;--------------------------------------------------------
          VS1001_TX_R19x32_CEROS:
         	; No enviar datos hasta que DREQ = 1
000bb2 9bb2      	sbis	VS1001_PIN, VS1001_DREQ
000bb3 cffe      	rjmp	VS1001_TX_R19x32_CEROS
         	
         	; Enviar 32 ceros seguidos:
000bb4 e000      	ldi	r16, 0x00
000bb5 e220      	ldi	r18, 32
          VS1001_RESET_tx_ceros_loop2:
000bb6 dfcb      	rcall	VS1001_TX_MPEG_DATA
000bb7 952a      	dec	r18
000bb8 f7e9      	brne	VS1001_RESET_tx_ceros_loop2
         	
000bb9 953a      	dec	r19
000bba f7b9      	brne	VS1001_TX_R19x32_CEROS
         	
000bbb 9508      	ret
         	
         
         
         ;--------------------------------------------------------
         ;  VS1001_CAMBIAR_VOLUMEN
         ;
         ;	r17: Nuevo volumen
         ;--------------------------------------------------------
          VS1001_CAMBIAR_VOLUMEN:
000bbc 2f21      	mov	r18, r17
000bbd 2f31      	mov	r19, r17
000bbe e01b      	ldi	r17, VS1001ADDR_VOL
000bbf cfa2      	rjmp	VS1001_ESC_REGISTRO
         	          .include "pulsadores.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: pulsadores.asm
         ;
         ; DESCRIPCION: 
         ;
         ;
         ;-----------------------------------------------------------------------------
         
         
         ; Son los mismos numeros que los comandos:
         ; ------------------------------------------
          .equ	PULS_VOL_MAS	= 8
          .equ	PULS_VOL_MENOS	= 7
          .equ	PULS_ATRAS	= 6
          .equ	PULS_ALANTE	= 5
          .equ	PULS_STOP	= 4
          .equ	PULS_PLAY	= 3
         
         ; Estos ya no son pulsadores, pero son comandos accesibles a 
         ;  traves del mando a distancia: (o botones si alguien los quiere poner)
          .equ	PULS_SUBE_DIR	= 2
         
         
         
         ;--------------------------------------------------------
         ;  LEE_PULSADORES
         ;
         ;  Devuelve en COMANDO_USUARIO la tecla pulsada o 0x00 si ninguna
         ;--------------------------------------------------------
          LEE_PULSADORES:
000bc0 df70      	rcall	DESHAB_EXTRAM
         	; Salida a cero para detectar pulsadas:
000bc1 9894      	cbi	PULSADORES_PORT, PULS_NUM_PIN
         	
         	; Sacar en PORTA todos a 1 pero con res. tiron nada mas:
000bc2 2700      	clr	r16
000bc3 bb0a      	out	DDRA, r16
000bc4 ef0f      	ser	r16
000bc5 bb0b      	out	PORTA, r16
         	
         	; Retardo de algunos micros:
000bc6 e09a      	ldi	r25, 10
000bc7 dc37      	rcall	RETARDO_R25_MAX100us
         	
000bc8 b319      	in	r17, PINA
         	
         	; Ahora, habra un cero en el pulsador que este activo:
         	
000bc9 e008      	ldi	r16, 0x08
         	
          lee_tecl_lp:
000bca 9408      	sec
000bcb 1f11      	rol	r17
000bcc f410      	brcc	lee_tecl_fin	; Si, era un cero: SALIR con r16=tecla
         	
         	; No estaba pulsada:
000bcd 950a      	dec	r16
000bce f7d9      	brne	lee_tecl_lp
         	
         	; Si no habia ninguna, saldra r16 con cero:
         		
         	
          lee_tecl_fin:
         
         	; Salida a uno de nuevo
000bcf 9a94      	sbi	PULSADORES_PORT, PULS_NUM_PIN
         	
000bd0 9508      	ret
         	          .include "ir.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: ir.asm
         ;
         ; DESCRIPCION: Mando a distancia
         ;
         ;-----------------------------------------------------------------------------
         
         
         
         ; --------------------------------------------------------
         ;	Int. del TIMER 0
         ;
         ; Usada para recoger los codigos del mando a distancia
         ;
         ; Se llama cada 304 us, la mitad del periodo de bit de IR
         ; 
         ; --------------------------------------------------------
          TMR0_INT:
000bd1 930f      	push	r16
         
000bd2 b70f      	in	r16, SREG
000bd3 930f      	push	r16
         
000bd4 b705      	in	r16, MCUCR
000bd5 930f      	push	r16
         
000bd6 931f      	push	r17
000bd7 932f      	push	r18
         	
         	; Quitar ram ext:
         	;  Esto evita pequeños glitchs en ALE aunque accedamos 
         	;   a RAM interna, lo que modificaria el valor en el 
         	;   registro 74HC373 externo !!
000bd8 e000      	ldi	r16, 0x00
000bd9 bf05      	out	MCUCR,r16
         	
         
         	; Salir si: 
         	;  - Ni estamos recibiendo
         	;  - Ni se detecta nada nuevo:
         	
         	; Leer bit de entrada del IR:
000bda 9100 018d 	lds	r16, IR_RX_BITS	
000bdc 2300      	tst	r16
000bdd f411      	brne	tmr0_si
         	
000bde 9983      	sbic	IR_PIN, IR_NUM_PIN
000bdf c045      	rjmp	tmr0_fin	; Es = 1 -> No detectado nada
         	
          tmr0_si:
         
         	; Procesar:
000be0 9983      	sbic	IR_PIN, IR_NUM_PIN
000be1 c010      	rjmp	tmr0_proc_0
         	
         	; Si hay señal:
         	; -------------
          tmr0_proc_1:
000be2 2700      	clr	r16
000be3 9300 018f 	sts	IR_CUENTA_0, r16
         
000be5 9100 018e 	lds	r16, IR_BITS_1
         	
         	; Si es el inicio, incrementar contador de bits:
000be7 2300      	tst	r16
000be8 f429      	brne	tmr0_no_prim
         	
000be9 9110 018d 	lds	r17, IR_RX_BITS
000beb 9513      	inc	r17	
000bec 9310 018d 	sts	IR_RX_BITS, r17
          tmr0_no_prim:
         	
000bee 9503      	inc	r16
000bef 9300 018e 	sts	IR_BITS_1, r16
         
000bf1 c033      	rjmp	tmr0_fin
         	
         	; No hay señal
         	; -------------
          tmr0_proc_0:
         	; Final de rafaga de unos?
000bf2 9100 018e 	lds	r16, IR_BITS_1
000bf4 2300      	tst	r16
000bf5 f079      	breq	tmr0_no_fin1s
         	
         	; Es el final: Ver si era corto o largo (0/1):
000bf6 3003      	cpi	r16, 3
         
000bf7 9100 0191 	lds	r16, IR_CODE+0
000bf9 9110 0192 	lds	r17, IR_CODE+1
         	
000bfb 9517      	ror	r17	; LSB
000bfc 9507      	ror	r16
         	
000bfd 9300 0191 	sts	IR_CODE+0, r16
000bff 9310 0192 	sts	IR_CODE+1, r17
         	
         	
         	; Dejar limpio contador para siguiente bit:	
000c01 2711      	clr	r17
000c02 9310 018e 	sts	IR_BITS_1, r17
         
         	; Ya hay 16 bits?
         	; Es mejor que solo acabe un codigo cuando ya 
         	;  se vean mucho rato la señal a cero :-)
         ;	lds	r17, IR_RX_BITS
         ;	cpi	r17, 16
         ;	breq	tmr0_analiza
         
         	
000c04 c020      	rjmp	tmr0_fin
         
          tmr0_no_fin1s:
         	; Si ya llevamos un rato con ceros, dar por terminada
         	;  la secuencia y procesar:
000c05 9100 018f 	lds	r16, IR_CUENTA_0
000c07 9503      	inc	r16
000c08 9300 018f 	sts	IR_CUENTA_0, r16
         	
000c0a 3006      	cpi	r16, 6
000c0b f4c9      	brne	tmr0_fin
         	
          tmr0_analiza:
         	; Desplazar el codigo los bits que falten hasta 16:
000c0c 9120 018d 	lds	r18, IR_RX_BITS
000c0e 9100 0191 	lds	r16, IR_CODE+0
000c10 9110 0192 	lds	r17, IR_CODE+1
         	
          tmr0_despl:
000c12 3120      	cpi	r18, 16
000c13 f021      	breq	tmr0_fin_despl
         
000c14 9517      	ror	r17	; LSB
000c15 9507      	ror	r16
         
000c16 9523      	inc	r18
000c17 cffa      	rjmp	tmr0_despl
         
         	
          tmr0_fin_despl:
000c18 9500      	com	r16
000c19 9510      	com	r17
         	
         	; En IR_CODE_FINAL queda el codigo de la tecla:
         	; -----------------------------------------------
         
         	; Ok, dar por bueno en codigo recibido:	
000c1a 9300 0193 	sts	IR_CODE_FINAL+0, r16
000c1c 9310 0194 	sts	IR_CODE_FINAL+1, r17
         	
         
         	; Reponer variables para proxima recepcion
000c1e 2700      	clr	r16	
000c1f 9300 018f 	sts	IR_CUENTA_0, r16
000c21 9300 018e 	sts	IR_BITS_1, r16
000c23 9300 018d 	sts	IR_RX_BITS, r16
         		
         	
         			
         
          tmr0_fin:
         	; Reponer valores y salir:
000c25 ed0a      	ldi	r16, ( 255  - 37 )
000c26 bf02      	out	TCNT0, r16
         	
000c27 e002      	ldi	r16, 0x02
000c28 bf08      	out	TIFR, r16
         
         
000c29 912f      	pop	r18
000c2a 911f      	pop	r17
         
000c2b 910f      	pop	r16
000c2c bf05      	out	MCUCR, r16
         	
000c2d 910f      	pop	r16
000c2e bf0f      	out	SREG, r16
000c2f 910f      	pop	r16
000c30 9518      	reti
         
         
         
         
         ; --------------------------------------------------------
         ;   IR_PROCESA_CODIGO
         ;
         ;  Transforma los codigos de teclas en comandos
         ; --------------------------------------------------------
          IR_PROCESA_CODIGO:
000c31 9010 0193 	lds	r1, IR_CODE_FINAL+0
000c33 9020 0194 	lds	r2, IR_CODE_FINAL+1
         	
000c35 2011      	tst	r1
000c36 f419      	brne	ir_proc_cod_si
000c37 2022      	tst	r2
000c38 f409      	brne	ir_proc_cod_si
         	
000c39 9508      	ret
         	
         	
          ir_proc_cod_si:
         	; Borrar codigo en RAM
000c3a 2722      	clr	r18
000c3b 9320 0193 	sts	IR_CODE_FINAL+0, r18
000c3d 9320 0194 	sts	IR_CODE_FINAL+1, r18
         
         
         	; Y ver que comando es el codigo actual:
000c3f e0b0      	ldi	XH, 0x00
000c40 e1a0      	ldi	XL, 0x10	; Posicion en eeprom de los codigos
000c41 e1f8      	ldi	ZH, high ( 2 * IR_TABLA_COD_CMDS )
000c42 ebe4      	ldi	ZL,  low ( 2 * IR_TABLA_COD_CMDS )
         	
          ir_proc_cod_lp:
000c43 95c8      	lpm
000c44 9631      	adiw	ZL, 1
         	
000c45 2000      	tst	r0
000c46 f091      	breq	ir_proc_cod_fin	
         	
         	; Leer de eep. el codigo para comparalo. 
         	; Guardarlo en r3, r4
000c47 d01a      	rcall	LEE_EEPROM
000c48 2e30      	mov	r3, r16	
000c49 d018      	rcall	LEE_EEPROM
000c4a 2e40      	mov	r4, r16	
         
         
         	; El codigo estaba en r1:r2
000c4b 1413      	cp	r1, r3
000c4c f7b1      	brne	ir_proc_cod_lp
000c4d 1424      	cp	r2, r4
000c4e f7a1      	brne	ir_proc_cod_lp
         	
         	; Si, esta es:
000c4f 9200 0178 	sts	COMANDO_USUARIO, r0
         	
         	; Si no es de volumen, poner un retardo:
000c51 2d00      	mov	r16, r0
000c52 3008      	cpi	r16, PULS_VOL_MAS
000c53 f029      	breq	ir_proc_cod_fin
000c54 3007      	cpi	r16, PULS_VOL_MENOS
000c55 f019      	breq	ir_proc_cod_fin
         	
         	
000c56 e001      	ldi	r16, VALOR_IR_TIMEOUT
000c57 9300 0190 	sts	IR_TIMEOUT, r16	
         
          ir_proc_cod_fin:
         
000c59 9508      	ret
         	
         
         ; Aqui estan por orden los numeros de comandos en el mismo orden 
         ;  en que en eeprom estan los codigos a partir de 0x0010
          IR_TABLA_COD_CMDS:
          	.db	PULS_PLAY,     PULS_PLAY
000c5a 0303
          	.db	PULS_STOP,     PULS_STOP
000c5b 0404
          	.db	PULS_ALANTE,   PULS_ALANTE
000c5c 0505
          	.db	PULS_ATRAS,    PULS_ATRAS
000c5d 0606
          	.db	PULS_VOL_MAS,  PULS_VOL_MAS 
000c5e 0808
          	.db 	PULS_VOL_MENOS,PULS_VOL_MENOS
000c5f 0707
          	.db	PULS_SUBE_DIR, PULS_SUBE_DIR
000c60 0202
          FIN_IR_TABLA_COD_CMDS:
          	.db	0,0	; Fin de lista
000c61 0000
         
         
         
         
         ; --------------------------------------------------------
         ;  LEE_EEPROM
         ;
         ;  EEP[X++] -> r16
         ; --------------------------------------------------------
000c62 99e1      LEE_EEPROM:   SBIC    EECR,1        
000c63 cffe                    RJMP    LEE_EEPROM      
000c64 bbae                    OUT     EEARL,XL     
000c65 bbbf                    OUT     EEARH,XH
000c66 9ae0                    SBI     EECR,0        
000c67 b30d                    IN      R16,EEDR      
000c68 9611                    ADIW    XL,0x1         
000c69 9508                    RET
         
                       
         ; --------------------------------------------------------
         ;  GRB_EEPROM
         ;
         ;  EEP[X++] <- r16
         ; --------------------------------------------------------
000c6a 99e1      GRB_EEP:     SBIC    EECR,1   
000c6b cffe                   RJMP    GRB_EEP 
000c6c bbae                   OUT     EEARL,XL  
000c6d bbbf                   OUT     EEARH,XH
000c6e bb0d                   OUT     EEDR,R16    ;EEPROM data register 
000c6f 9ae2                   SBI     EECR,2         
000c70 9ae1                   SBI     EECR,1
000c71 9611                   ADIW    XL,0x1     
000c72 9508                   RET
          .include "ft245_usb.asm"
         ;-----------------------------------------------------------------------------
         ; FICHERO: ft245_usb.asm
         ;
         ; DESCRIPCION: Comunicacion con el chip FT245BM de FTDI para conectividad
         ; 		 usando USB.
         ;
         ;-----------------------------------------------------------------------------
         
         ;-----------------------------------------------------------------------------
         ; USB_INICIAR
         ;
         ;  Iniciar pins
         ;-----------------------------------------------------------------------------
          USB_INICIAR:
         	; /RD: Salida a uno
000c73 9a88      	sbi	USB_DDR,  USB_PIN_RD
000c74 9a90      	sbi	USB_PORT, USB_PIN_RD
         	
         	; WR: Salida a cero
000c75 9a89      	sbi	USB_DDR,  USB_PIN_WR
000c76 9891      	cbi	USB_PORT, USB_PIN_WR
         	
         	; RXF: Entrada, con tiron
000c77 9a92      	sbi	USB_PORT, USB_PIN_RXF
000c78 988a      	cbi	USB_DDR, USB_PIN_RXF
         	
         
000c79 9508      	ret
         	
         
         ;-----------------------------------------------------------------------------
         ;
         ;	En este modo solo se procesan paquetes desde el PC
         ;
         ;  Los paquetes que se reciben son:
         ;
         ;  COMANDO           		 DATOS 
         ; ---------			-------
         ;    0x10 Leer sector		4 bytes sector LBA 
         ;    0x20 Escribir sector	4 bytes sector LBA + 512 bytes datos + 4 bytes 
         ;				  de los que el 1º es el XOR de los 512 bytes de datos
         ;    0x05 Obtener ID
         ;    0x06 Reset de sistema	
         ;
         ;-----------------------------------------------------------------------------
          MODO_USB:
000c7a 94f8      	cli
000c7b e000      	ldi	r16, 0
000c7c bf03      	out	TCCR0,r16
         	
         	
000c7d dff5      	rcall	USB_INICIAR
         
000c7e deb2      	rcall	DESHAB_EXTRAM
         
000c7f dda5      	rcall	LCD_BORRAR
         	
000c80 e1f5      	ldi	ZH, high( STR_USB * 2)
000c81 ebee      	ldi	ZL,  low( STR_USB * 2)
000c82 ddd6      	rcall	LCD_ESCRIBE_CADENA_Z_FLASH
         
         
          modo_usb_lp:
         	; Algun paquete?
         	; ---------------------
000c83 9b82      	sbis	USB_PIN, USB_PIN_RXF
000c84 c006      	rjmp	usb_procesa_paquete ; RXF = 0
         	
         		
         	; Si se pulsa alguna tecla, se sale del modo USB:
000c85 d8d3      	rcall	LEE_PULS_Y_IR
000c86 9100 0178 	lds	r16, COMANDO_USUARIO	; Del tecl o IR
000c88 2300      	tst	r16
000c89 f3c9      	breq	modo_usb_lp
         	
         	; Si, salir: Hacer un reset del sistema
          usb_ve_reset:
000c8a c37f      	rjmp	RESET
         
         
         
         
         ;-----------------------------------------------------------------------------
         ;  Recibir paquete y procesarla
         ;-----------------------------------------------------------------------------
          usb_procesa_paquete:
         	; Recibir paquete en buffer:
000c8b e4b8      	ldi	XH, high (USB_COMANDO)
000c8c e0a0      	ldi	XL,  low (USB_COMANDO)
         	
000c8d dea3      	rcall	DESHAB_EXTRAM
         	
         	; El numero de comando:
000c8e d0a1      	rcall	USB_RX_BYTE
         	
         	
000c8f de9c      	rcall	HAB_EXTRAM
000c90 930d      	st	X+, r16
         	
         	; Poner contador de bytes segun comando (en bloques de 4 bytes)
000c91 e021      	ldi	r18, 1	; CMD = 0x10
         	
000c92 3200      	cpi	r16, 0x20 ; Escribir sector
000c93 f409      	brne	usb_proc_paq_lp	
         	
000c94 e822      	ldi	r18, 130	; CMD = 0x20
         	
         	; Los datos:
          usb_proc_paq_lp:	
000c95 de9b      	rcall	DESHAB_EXTRAM
         	
000c96 d099      	rcall	USB_RX_BYTE
000c97 2e10      	mov	r1, r16
000c98 d097      	rcall	USB_RX_BYTE
000c99 2e20      	mov	r2, r16
000c9a d095      	rcall	USB_RX_BYTE
000c9b 2e30      	mov	r3, r16
000c9c d093      	rcall	USB_RX_BYTE
000c9d 2e40      	mov	r4, r16
         	
000c9e de8d      	rcall	HAB_EXTRAM
         	
000c9f 921d      	st	X+, r1
000ca0 922d      	st	X+, r2
000ca1 923d      	st	X+, r3
000ca2 924d      	st	X+, r4
         	
000ca3 952a      	dec	r18
000ca4 f781      	brne	usb_proc_paq_lp
         	
         	
         	; Ejecutar:
000ca5 9100 4800 	lds	r16, USB_COMANDO
000ca7 3100      	cpi	r16, 0x10
000ca8 f1d1      	breq	USB_READ_SECTOR
         
000ca9 3005      	cpi	r16, 0x05
000caa f031      	breq	USB_TEST
         
000cab 3006      	cpi	r16, 0x06
000cac f2e9      	breq	usb_ve_reset
         			
000cad 3200      	cpi	r16, 0x20
000cae f009      	breq	veUSB_WRITE_SECTOR
         
000caf cfd3      	rjmp	modo_usb_lp
         
          veUSB_WRITE_SECTOR:
000cb0 c057      	rjmp	USB_WRITE_SECTOR
         
         ;-----------------------------------------------------------------------------
         ;  CMD: TEST
         ;
         ;  Pone en display los 4 bytes enviados y 
         ;
         ;  RESP: Una cadena de 14 caracteres fijos:
         ;-----------------------------------------------------------------------------
          USB_TEST:
000cb1 de7a      	rcall	HAB_EXTRAM
         	
000cb2 9010 4801 	lds	r1, USB_DATA+0
000cb4 9020 4802 	lds	r2, USB_DATA+1
000cb6 9030 4803 	lds	r3, USB_DATA+2
000cb8 9040 4804 	lds	r4, USB_DATA+3
         	
000cba de76      	rcall	DESHAB_EXTRAM
         	
000cbb e400      	ldi	r16, 0x40
000cbc dda8      	rcall	LCD_SET_CURSOR_POS_R16
         
000cbd 2d01      	mov	r16, r1
000cbe ddab      	rcall	LCD_ESCRIBE_R16_HEX
000cbf 2d02      	mov	r16, r2
000cc0 dda9      	rcall	LCD_ESCRIBE_R16_HEX
000cc1 2d03      	mov	r16, r3
000cc2 dda7      	rcall	LCD_ESCRIBE_R16_HEX
000cc3 2d04      	mov	r16, r4
000cc4 dda5      	rcall	LCD_ESCRIBE_R16_HEX	
         
         
000cc5 de6b      	rcall	DESHAB_EXTRAM
         
000cc6 e407      	ldi	r16, 'G'
000cc7 d071      	rcall	USB_TX_BYTE
000cc8 e609      	ldi	r16, 'i'
000cc9 d06f      	rcall	USB_TX_BYTE
000cca e607      	ldi	r16, 'g'
000ccb d06d      	rcall	USB_TX_BYTE
000ccc e601      	ldi	r16, 'a'
000ccd d06b      	rcall	USB_TX_BYTE
000cce e40d      	ldi	r16, 'M'
000ccf d069      	rcall	USB_TX_BYTE
000cd0 e500      	ldi	r16, 'P'
000cd1 d067      	rcall	USB_TX_BYTE
000cd2 e303      	ldi	r16, '3'
000cd3 d065      	rcall	USB_TX_BYTE
000cd4 e200      	ldi	r16, ' '
000cd5 d063      	rcall	USB_TX_BYTE
000cd6 e706      	ldi	r16, 'v'
000cd7 d061      	rcall	USB_TX_BYTE
000cd8 e40a      	ldi	r16, 'J'
000cd9 d05f      	rcall	USB_TX_BYTE
000cda e505      	ldi	r16, 'U'
000cdb d05d      	rcall	USB_TX_BYTE
000cdc e40c      	ldi	r16, 'L'
000cdd d05b      	rcall	USB_TX_BYTE
000cde e300      	ldi	r16, '0'
000cdf d059      	rcall	USB_TX_BYTE
000ce0 e303      	ldi	r16, '3'
000ce1 d057      	rcall	USB_TX_BYTE
         	
         	
         	; Fin de comando
000ce2 cfa0      	rjmp	modo_usb_lp
         	
         
         ;-----------------------------------------------------------------------------
         ;  CMD: Leer sector
         ;  RESP: Los 512 bytes
         ;-----------------------------------------------------------------------------
          USB_READ_SECTOR:
000ce3 de48      	rcall	HAB_EXTRAM
         	
000ce4 9100 4801 	lds	r16, USB_COMANDO+1
000ce6 9300 0074 	sts	LBA_DIR+0,r16
000ce8 9100 4802 	lds	r16, USB_COMANDO+2
000cea 9300 0075 	sts	LBA_DIR+1,r16
000cec 9100 4803 	lds	r16, USB_COMANDO+3
000cee 9300 0076 	sts	LBA_DIR+2,r16
000cf0 9100 4804 	lds	r16, USB_COMANDO+4
000cf2 9300 0077 	sts	LBA_DIR+3,r16
         	
000cf4 e001      	ldi	r16, 0x01
000cf5 9300 0078 	sts	SECTOR_CNT, r16
         	
000cf7 e4d8      	ldi	YH, high ( USB_DATA )
000cf8 e0c1      	ldi	YL, low  ( USB_DATA )
         	
000cf9 dc18      	rcall	ATA_ReadSectors
         
         	
         	; Y ahora enviar los 512 bytes:
         	; ---------------------------------
000cfa e4d8      	ldi	YH, high ( USB_DATA )
000cfb e0c1      	ldi	YL, low  ( USB_DATA )
         	
000cfc e020      	ldi	r18, 0
          usb_cmd_rd_lp1:
000cfd de2e      	rcall	HAB_EXTRAM
000cfe 9109      	ld	r16, Y+
000cff de31      	rcall	DESHAB_EXTRAM
000d00 d038      	rcall	USB_TX_BYTE		
         
000d01 de2a      	rcall	HAB_EXTRAM
000d02 9109      	ld	r16, Y+
000d03 de2d      	rcall	DESHAB_EXTRAM
000d04 d034      	rcall	USB_TX_BYTE		
         
000d05 952a      	dec	r18
000d06 f7b1      	brne	usb_cmd_rd_lp1
         
         	; Fin de comando
000d07 cf7b      	rjmp	modo_usb_lp
         	
         	
         ;-----------------------------------------------------------------------------
         ;  CMD: Write Sector
         ;
         ; 
         ;  RESP: 0x10 si XOR OK y escrito.
         ;        0x20 si XOR ERROR !
         ;-----------------------------------------------------------------------------
          USB_WRITE_SECTOR:
         	; Comprobar XOR !!
         
000d08 e4b8      	ldi	XH, high ( USB_DATA+4 )
000d09 e0a5      	ldi	XL, low  ( USB_DATA+4 )
         	
000d0a 2711      	clr	r17	
          usbwrsect_xor:
000d0b 910d      	ld	r16, X+
000d0c 2711      	eor	r17, r17
         	
000d0d 30a5      	cpi	XL, low  ( USB_DATA+4 +512 )
000d0e f7e1      	brne	usbwrsect_xor
000d0f 34ba      	cpi	XH, high ( USB_DATA+4 +512 )
000d10 f7d1      	brne	usbwrsect_xor
         	
000d11 910d      	ld	r16, X+
000d12 1701      	cp	r16, r17
         	
000d13 f019      	breq	usbwrsect_Ok
         
         	; Enviar 0x20 indicando error de XOR:
000d14 e200      	ldi	r16, 0x20	
000d15 d023      	rcall	USB_TX_BYTE		
         	
         	; Fin de comando
000d16 cf6c      	rjmp	modo_usb_lp
         
         	
          usbwrsect_Ok:
         	; Poner LBA:
000d17 9100 4801 	lds	r16, USB_COMANDO+1
000d19 9300 0074 	sts	LBA_DIR+0,r16
000d1b 9100 4802 	lds	r16, USB_COMANDO+2
000d1d 9300 0075 	sts	LBA_DIR+1,r16
000d1f 9100 4803 	lds	r16, USB_COMANDO+3
000d21 9300 0076 	sts	LBA_DIR+2,r16
000d23 9100 4804 	lds	r16, USB_COMANDO+4
000d25 9300 0077 	sts	LBA_DIR+3,r16
         	
000d27 e001      	ldi	r16, 0x01
000d28 9300 0078 	sts	SECTOR_CNT, r16
         	
000d2a e4d8      	ldi	YH, high ( USB_DATA+4 )
000d2b e0c5      	ldi	YL, low  ( USB_DATA+4 )
         	
000d2c dc46      	rcall	ATA_WriteSectors
         	
         
         	; Enviar 0x10 de confirmacion:
000d2d e100      	ldi	r16, 0x10	
000d2e d00a      	rcall	USB_TX_BYTE		
         
         	; Fin de comando
000d2f cf53      	rjmp	modo_usb_lp
         
         
         ;-----------------------------------------------------------------------------
         ;  Recibe un byte (en r16)
         ;-----------------------------------------------------------------------------
          USB_RX_BYTE:
         	; Asegurar que RXF = 0
000d30 9982      	sbic	USB_PIN, USB_PIN_RXF
000d31 cffe      	rjmp	USB_RX_BYTE
         	
000d32 2700      	clr	r16
000d33 bb0a      	out	DDRA,r16
         	
         	; Ciclo de lectura:
000d34 9890      	cbi	USB_PORT, USB_PIN_RD
000d35 0000      	nop
000d36 b309      	in	r16, PINA
000d37 9a90      	sbi	USB_PORT, USB_PIN_RD
         
         	
000d38 9508      	ret
         	
         ;-----------------------------------------------------------------------------
         ;  Envia un byte (en r16)
         ;-----------------------------------------------------------------------------
          USB_TX_BYTE:
         	; PORTC = entrada y pull-ups	
000d39 2711      	clr	r17
000d3a bb14      	out	DDRC, r17		
000d3b ef1f      	ser	r17
000d3c bb15      	out	PORTC, r17
         
         	; PORTA = DATOS
000d3d bb1a      	out	DDRA, r17
000d3e bb0b      	out	PORTA, r16
         	
         
          usb_tx_lp:
000d3f 9998      	sbic	PINC, 0		; A8 conectada a TXE
000d40 cffe      	rjmp	usb_tx_lp	;  Debe estar a 0 para enviar
         	
         	
         	; Ciclo de Escritura:
000d41 9a91      	sbi	USB_PORT, USB_PIN_WR
000d42 0000      	nop
000d43 9891      	cbi	USB_PORT, USB_PIN_WR
         	
000d44 9508      	ret
         		
         	
         
         	          .include "CrearLista.asm"         ;----------------------------------------------------
         ; FICHERO: CrearLista.asm
         ;
         ; DESCRIPCION: Rutinas de exploracion de directorios
         ;               y creacion de listas de reproduccion
         ;
         ; Jose Luis Blanco Claraco @ 2001-2002
         ;----------------------------------------------------
         
         
         ; --------------------------------------------------------
         ;  SELEC_FICH_LISTA_ORDEN_R16
         ;
         ;  Selecciona el fichero numero r16 segun el indice en el 
         ;   array LST_REPR_ORDEN
         ; --------------------------------------------------------
          SELEC_FICH_LISTA_ORDEN_R16:
000d45 dde6      	rcall	HAB_EXTRAM
         
000d46 e4bb      	ldi	XH, high ( LST_REPR_ORDEN )
000d47 e4a2      	ldi	XL,  low ( LST_REPR_ORDEN )
         	
         	; El primero es 1:
000d48 950a      	dec	r16
000d49 2400      	clr	r0
         	
000d4a 0fa0      	add	XL, r16
000d4b 1db0      	adc	XH, r0
         	
         	; Coger indice:
000d4c 910c      	ld	r16, X
         
         	; Y ahora seleccionar ese fichero:
000d4d c000      	rjmp	SELEC_FICH_LISTA_R16
         
         ; --------------------------------------------------------
         ;  SELEC_FICH_LISTA_R16
         ;
         ;  Selecciona el fichero numero r16 de la lista formada.
         ;   Coge el numero indicado, no el indexado por la lista 
         ;   de LST_REPR_ORDEN, para eso hay que leer esa entrada
         ;   y luego llamar a esta rutina.
         ; --------------------------------------------------------
          SELEC_FICH_LISTA_R16:
000d4e dddd      	rcall	HAB_EXTRAM
         
         	; Contador de entradas en la lista
000d4f e050      	ldi	r21, 0
         	
         	; Puntero que recorre la lista:
000d50 e4bc      	ldi	XH, high ( LST_REPR_LISTA )
000d51 e4a2      	ldi	XL,  low ( LST_REPR_LISTA )
         	
         	; Contador de entradas que quedan en este directorio:
000d52 e060      	ldi	r22, 0x00	; para q nada mas empezar cargue el primero:
         
          selecfichlst_lp:
         	; Fin de lista?
000d53 9110 4b41 	lds	r17, LST_REPR_CUANTOS
000d55 1715      	cp	r17, r21
000d56 f0d1      	breq	selecfichlst_fin	; No encontrado en lista !!
         	
         	; Buscar siguiente 	
000d57 2366      	tst	r22
000d58 f429      	brne	selecfchlst_no_fin_dir
         	
         	; Si, cargar nuevo directorio:
000d59 916d      	ld	r22, X+	; Numero de entradas en nuevo directorio:
         
000d5a 902d      	ld	r2, X+	; Cluster del directorio:
000d5b 903d      	ld	r3, X+
000d5c 904d      	ld	r4, X+
000d5d 905d      	ld	r5, X+
         	
         	
          selecfchlst_no_fin_dir:	
         	; Coger fichero:
000d5e 917d      	ld	r23, X+	; Es el numero de entrada en el dir. actual
         	
000d5f 956a      	dec	r22	; Num. de fichs q quedan en directorio
000d60 9553      	inc	r21	; Num. de entrada en la lista total
         	
         	; Es el pedido?
000d61 1750      	cp	r21, r16
000d62 f781      	brne	selecfichlst_lp
         	
         	; Si, es el pedido, cargar:
000d63 9220 0109 	sts	FAT_DIRECT_ACTUAL+0, r2
000d65 9230 010a 	sts	FAT_DIRECT_ACTUAL+1, r3
000d67 9240 010b 	sts	FAT_DIRECT_ACTUAL+2, r4
000d69 9250 010c 	sts	FAT_DIRECT_ACTUAL+3, r5
         	
000d6b e001      	ldi	r16, 0x01
000d6c 9300 0111 	sts	FAT_PETICION, r16
         	
000d6e 9370 0112 	sts	FAT_PETICION_NUM_ENTR, r23
         	
         	
000d70 d939      	rcall	FAT_EXPLORA_DIRECTORIO
         	
          selecfichlst_fin:
         
000d71 9508      	ret
         
         
         
         ; --------------------------------------------------------
         ; ES_DIRENTRY_DIRECT_VALIDO
         ;
         ;  Devuelve CARRY=1 si en DE_XXX hay un directorio y no 
         ;   es ni "." ni ".."
         ; --------------------------------------------------------
          ES_DIRENTRY_DIRECT_VALIDO:
000d72 9100 0118 	lds	r16, FATDE_ATTR
000d74 ff04      	sbrs	r16, 4	; 0x10 = DIR
000d75 c014      	rjmp	ESDEDIRVAL_fin_no
         
000d76 9110 0121 	lds	r17, FATDE_FILENAME+0
000d78 9120 0122 	lds	r18, FATDE_FILENAME+1
000d7a 9130 0123 	lds	r19, FATDE_FILENAME+2
         	
000d7c 321e      	cpi	r17, '.'
000d7d f419      	brne	ESDEDIRVAL_no_punto
000d7e 3020      	cpi	r18, 0
000d7f f409      	brne	ESDEDIRVAL_no_punto
         	
         	; Es "."
000d80 c009      	rjmp	ESDEDIRVAL_fin_no
         	
          ESDEDIRVAL_no_punto:
         
000d81 321e      	cpi	r17, '.'
000d82 f429      	brne	ESDEDIRVAL_no_punto_punto
000d83 322e      	cpi	r18, '.'
000d84 f419      	brne	ESDEDIRVAL_no_punto_punto
000d85 3030      	cpi	r19, 0
000d86 f409      	brne	ESDEDIRVAL_no_punto_punto
         	
         	; Es ".."
000d87 c002      	rjmp	ESDEDIRVAL_fin_no
         
          ESDEDIRVAL_no_punto_punto:
         	; SI
000d88 9408      	sec
000d89 9508      	ret
         
          ESDEDIRVAL_fin_no:
000d8a 9488      	clc
000d8b 9508      	ret
         
         
         ; --------------------------------------------------------
         ;  FORMAR_LISTA_REPRODUCCION
         ;
         ;  Rutina recursiva que crea una lista con ficheros .MP3 
         ;   a partir del directorio que hay en FATDE_CLUSTER
         ;
         ;LST_REPR_CUANTOS:	.byte	1	; Numero de entradas en lista
         ;LST_REPR_ORDEN:		.byte	256	; Indices dentro de la lista siguiente:
         ;LST_REPR_LISTA:		.byte	400	; Para que sobre... segun el numero de 
         ;
         ; --------------------------------------------------------
          FORMAR_LISTA_REPRODUCCION:
000d8c dd9f      	rcall	HAB_EXTRAM
         
         
         
         	; Parte que solo se ejecuta una vez: Iniciar lista:
         	; ---------------------------------------------------
000d8d 2700      	clr	r16
000d8e 9300 4b41 	sts	LST_REPR_CUANTOS, r16
         
         	; Vaciar cola de directorios a explorar
000d90 2700      	clr	r16
000d91 9300 4b3f 	sts	CREAR_LST_COLA_PTR_IN, r16
000d93 9300 4b40 	sts	CREAR_LST_COLA_PTR_OUT, r16
         	
         	; Y meter en cola el directorio seleccionado ahora:
000d95 d051      	rcall	FORMARLISTA_ADD_DIR_COLA
         
         	; Con X voy apuntando a la entrada en la lista:
000d96 e4bc      	ldi	XH, high ( LST_REPR_LISTA )
000d97 e4a2      	ldi	XL, low  ( LST_REPR_LISTA )
         
         	; ------------------------------------------------
         	; El fomato de la lista es:
         	;
         	;  BYTES   CONTENIDO
         	; ====================
         	;    1       Numero de entradas en este directorio
         	;    4       Cluster del directorio 
         	;   Nx1	     Numero del fichero en ese directorio
         	;
         	; ------------------------------------------------
         
         
         ; ---------------------------------------------------
         ;
         ;  Parte de bucle para cada directorio
         ;
         ; ---------------------------------------------------
          frm_lst_repr_expl_sig_dir:
         	; Coger directorio de la cola:
000d98 d076      	rcall	FORMARLISTA_GET_DIR_COLA
000d99 f408      	brcc	frm_lst_repr_si_mas_dirs 	; C=1 = No hay mas! Se acabo el formar la lista
000d9a c04b      	rjmp	frm_lst_repr_fin
         	
          frm_lst_repr_si_mas_dirs:
         	; Guardar puntero para luego poner numero de fichs MP3 encontrados:
000d9b 93af      	push	XL
000d9c 93bf      	push	XH	
000d9d e000      	ldi	r16, 0
000d9e 930d      	st	X+, r16	; por ahora, dejar un cero:
         	
         	; Ahora el cluster del directorio y
         	; Entrar en directorio:
000d9f 9100 0119 	lds	r16, FATDE_CLUSTER+0
000da1 9300 0109 	sts	FAT_DIRECT_ACTUAL+0, r16
000da3 930d      	st	X+, r16
         	
000da4 9100 011a 	lds	r16, FATDE_CLUSTER+1
000da6 9300 010a 	sts	FAT_DIRECT_ACTUAL+1, r16
000da8 930d      	st	X+, r16
         	
000da9 9100 011b 	lds	r16, FATDE_CLUSTER+2
000dab 9300 010b 	sts	FAT_DIRECT_ACTUAL+2, r16
000dad 930d      	st	X+, r16
         	
000dae 9100 011c 	lds	r16, FATDE_CLUSTER+3
000db0 9300 010c 	sts	FAT_DIRECT_ACTUAL+3, r16
000db2 930d      	st	X+, r16
         	
         	
         	; Ver cuantas entradas hay aqui:
000db3 e000      	ldi	r16, 0x00
000db4 9300 0111 	sts	FAT_PETICION, r16
         	
000db6 d8f3      	rcall	FAT_EXPLORA_DIRECTORIO
         	
000db7 dd74      	rcall	HAB_EXTRAM
         
         	; En r10 guardo el numero de entradas en este directorio:
000db8 90a0 0113 	lds	r10, FAT_DIRENT_ENCONTRADAS
000dba 94a3      	inc	r10	; Para que al compararlo y sea igual, sea el fin
         	
         	; Con r11 voy recorriendo cada elemento:
000dbb 24bb      	clr	r11
000dbc 94b3      	inc	r11
         	
         	; Con r12 cuento el numero de fichs. MP3 encontrados:
000dbd 24cc      	clr	r12
         	
         		
         ; ---------------------------------------------------
         ;
         ;  Parte de bucle para cada fich. en cada directorio
         ;
         ; ---------------------------------------------------
          frm_lst_repr_sig_fich:
000dbe 14ba      	cp	r11, r10	; Ya no hay mas?
000dbf f441      	brne	frm_lst_repr_si_mas_fichs
         	
         	; Ya no hay mas ficheros: 
         	; --------------------------
         	
         	; Ahora hay que terminar la entrada en la lista con 
         	;  el numero de fichs q se han encontrado:
000dc0 91df      	pop	YH
000dc1 91cf      	pop	YL
         	
000dc2 82c8      	st	Y, r12
         	
         	; Si en este directorio no habia MP3s, recuperar (X):
000dc3 20cc      	tst	r12
000dc4 f411      	brne	frm_lst_repr_si_habia
         	
         	; Directorio sin MP3s:
000dc5 2fbd      	mov	XH, YH
000dc6 2fac      	mov	XL, YL
         	
          frm_lst_repr_si_habia:	
         	; Y pasar al siguiente directorio:
000dc7 cfd0      	rjmp	frm_lst_repr_expl_sig_dir
         			
         	
          frm_lst_repr_si_mas_fichs:
         
         	; Ver entrada:
000dc8 e001      	ldi	r16, 0x01
000dc9 9300 0111 	sts	FAT_PETICION, r16
000dcb 92b0 0112 	sts	FAT_PETICION_NUM_ENTR, r11	
000dcd d8dc      	rcall	FAT_EXPLORA_DIRECTORIO
         
000dce dd5d      	rcall	HAB_EXTRAM
         
         
         	; Ver si es un directorio:
000dcf 9100 0118 	lds	r16, FATDE_ATTR
000dd1 fd04      	sbrc	r16, 4	; 0x10 = Dir:
000dd2 c00e      	rjmp	frm_lst_repr_es_dir
         
         	; Es un fichero:
         	; ------------------------
000dd3 da11      	rcall	TEST_FILENAME_ES_MP3 ; C=1 si SI lo es.
000dd4 f478      	brcc	frm_lst_repr_siguiente	; NO
         	
         	; Si es MP3: Añadir a la lista:
000dd5 9100 4b41 	lds	r16, LST_REPR_CUANTOS	; Vigilar limite de 255!!
000dd7 3f0f      	cpi	r16, 0xFF
000dd8 f059      	breq	frm_lst_repr_siguiente
         
         
000dd9 94c3      	inc	r12	; Contador de fichs. encontrados:	
         	
000dda 92bd      	st	X+, r11	; Num. de entrada en este directorio	
         	
         	; Y contador global:
000ddb 9100 4b41 	lds	r16, LST_REPR_CUANTOS
000ddd 9503      	inc	r16
000dde 9300 4b41 	sts	LST_REPR_CUANTOS, r16
         	
         	; Siguiente:
000de0 c003      	rjmp	frm_lst_repr_siguiente
         		
         	
         	; Es un directorio:
         	; ------------------------
          frm_lst_repr_es_dir:	
000de1 df90      	rcall	ES_DIRENTRY_DIRECT_VALIDO
000de2 f408      	brcc	frm_lst_repr_siguiente ; Dir no valido para explorar
         	
         	; Si, añadir a la cola de reproduccion:
000de3 d003      	rcall	FORMARLISTA_ADD_DIR_COLA
         	
         
         	
          frm_lst_repr_siguiente:
         	; Pasar a la siguiente entrada dentro de este directorio
         	; -------------------------------------------------------
000de4 94b3      	inc	r11		; Siguiente entrada
000de5 cfd8      	rjmp	frm_lst_repr_sig_fich
         
         
         
         	; Salir, lista ya formada	
          frm_lst_repr_fin:
         
         
         			
000de6 9508      	ret
         
         
         ; --------------------------------------------------------
         ;  FORMARLISTA_ADD_DIR_COLA
         ; 
         ;   Añade el directorio DE_CLUSTER a la cola de exploracion
         ;
         ;
         ;CREAR_LST_COLA_DIRS:	.byte	4*70	; Numero de directorios max. en cola
         ;CREAR_LST_COLA_PTR_IN:	.byte   1	; Punteros de indice (1º=0) de entrada y salida en cola
         ;CREAR_LST_COLA_PTR_OUT:	.byte   1	
         ;
         ; --------------------------------------------------------
          FORMARLISTA_ADD_DIR_COLA:
000de7 930f      	push	r16
000de8 931f      	push	r17
000de9 93bf      	push	XH
000dea 93af      	push	XL
         	
         	; Apuntar a entrada:
         	;  CREAR_LST_COLA_DIRS[ CREAR_LST_COLA_PTR_IN ]
000deb e4ba      	ldi	XH, high ( CREAR_LST_COLA_DIRS )
000dec e2a7      	ldi	XL,  low ( CREAR_LST_COLA_DIRS )
         	
000ded 9100 4b3f 	lds	r16, CREAR_LST_COLA_PTR_IN
000def 2711      	clr	r17
         	
         	; *= 4
000df0 0f00      	lsl	r16
000df1 1f11      	rol	r17
         
000df2 0f00      	lsl	r16
000df3 1f11      	rol	r17
         	
         	; Sumar a puntero:
000df4 0fa0      	add	XL, r16
000df5 1fb1      	adc	XH, r17
         	
         	
         	; X apunta a donde debemos meter la nueva entrada:
000df6 9100 0119 	lds	r16, FATDE_CLUSTER+0
000df8 930d      	st	X+, r16
000df9 9100 011a 	lds	r16, FATDE_CLUSTER+1
000dfb 930d      	st	X+, r16
000dfc 9100 011b 	lds	r16, FATDE_CLUSTER+2
000dfe 930d      	st	X+, r16
000dff 9100 011c 	lds	r16, FATDE_CLUSTER+3
000e01 930d      	st	X+, r16
         
         
         	
         	; Incrementar puntero de entradas:
000e02 9100 4b3f 	lds	r16, CREAR_LST_COLA_PTR_IN
000e04 9503      	inc	r16
         	
         	; Final? Es circular:
000e05 3406      	cpi	r16, TAM_CREARLISTAS_COLA	
000e06 f409      	brne	frmlst_add_fin
         	
         	; Al principio:
000e07 2700      	clr	r16
         	
          frmlst_add_fin:
000e08 9300 4b3f 	sts	CREAR_LST_COLA_PTR_IN, r16
         	
000e0a 91af      	pop	XL
000e0b 91bf      	pop	XH
000e0c 911f      	pop	r17
000e0d 910f      	pop	r16
000e0e 9508      	ret
         	
         ; --------------------------------------------------------
         ;  FORMARLISTA_GET_DIR_COLA
         ; 
         ;   Devuelve en DE_CLUSTER un directorio de la cola
         ;
         ;   CARRY=1 si ya no hay mas!
         ;
         ;
         ;CREAR_LST_COLA_DIRS:	.byte	4*70	; Numero de directorios max. en cola
         ;CREAR_LST_COLA_PTR_IN:	.byte   1	; Punteros de indice (1º=0) de entrada y salida en cola
         ;CREAR_LST_COLA_PTR_OUT:	.byte   1	
         ;
         ; --------------------------------------------------------
          FORMARLISTA_GET_DIR_COLA:
000e0f 930f      	push	r16
000e10 931f      	push	r17
000e11 93bf      	push	XH
000e12 93af      	push	XL
         	
         	; No hay mas si PTR_IN=PTR_OUT:
000e13 9100 4b40 	lds	r16, CREAR_LST_COLA_PTR_OUT
000e15 9110 4b3f 	lds	r17, CREAR_LST_COLA_PTR_IN
000e17 1701      	cp	r16, r17
000e18 f411      	brne	frmlstgetdir_sihay
         	
         	; No hay:
000e19 9408      	sec	
000e1a c020      	rjmp	frmlst_get_sal
         	
          frmlstgetdir_sihay:	
         	; Apuntar a entrada:
         	;  CREAR_LST_COLA_DIRS[ CREAR_LST_COLA_PTR_OUT ]
000e1b e4ba      	ldi	XH, high ( CREAR_LST_COLA_DIRS )
000e1c e2a7      	ldi	XL,  low ( CREAR_LST_COLA_DIRS )
         	
000e1d 9100 4b40 	lds	r16, CREAR_LST_COLA_PTR_OUT
000e1f 2711      	clr	r17
         	
         	; *= 4
000e20 0f00      	lsl	r16
000e21 1f11      	rol	r17
         
000e22 0f00      	lsl	r16
000e23 1f11      	rol	r17
         	
         	; Sumar a puntero:
000e24 0fa0      	add	XL, r16
000e25 1fb1      	adc	XH, r17
         
         	
         	; X apunta a donde debemos meter la nueva entrada:
000e26 910d      	ld	r16, X+
000e27 9300 0119 	sts	FATDE_CLUSTER+0, r16
000e29 910d      	ld	r16, X+
000e2a 9300 011a 	sts	FATDE_CLUSTER+1, r16
000e2c 910d      	ld	r16, X+
000e2d 9300 011b 	sts	FATDE_CLUSTER+2, r16
000e2f 910d      	ld	r16, X+
000e30 9300 011c 	sts	FATDE_CLUSTER+3, r16
         
         
         
         
         	; Incrementar puntero de entradas:
000e32 9100 4b40 	lds	r16, CREAR_LST_COLA_PTR_OUT
000e34 9503      	inc	r16
         	
         	; Final? Es circular:
000e35 3406      	cpi	r16, TAM_CREARLISTAS_COLA	
000e36 f409      	brne	frmlst_get_fin
         	
         	; Al principio:
000e37 2700      	clr	r16
         	
          frmlst_get_fin:
000e38 9300 4b40 	sts	CREAR_LST_COLA_PTR_OUT, r16
         	
000e3a 9488      	clc	; No era el final
         		
          frmlst_get_sal:	
000e3b 91af      	pop	XL
000e3c 91bf      	pop	XH
000e3d 911f      	pop	r17
000e3e 910f      	pop	r16
000e3f 9508      	ret
         
         	

Assembly complete with no errors.
